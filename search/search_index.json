{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"architecture/","title":"Architecture de Vectra","text":"<p>Vectra est une solution de RAG (Retrieval-Augmented Generation) d'entreprise con\u00e7ue pour transformer des donn\u00e9es non structur\u00e9es en connaissances exploitables via une interface de chat intelligente.</p>"},{"location":"architecture/#vue-densemble","title":"Vue d'Ensemble","text":"<p>L'architecture suit un mod\u00e8le distribu\u00e9 compos\u00e9 d'une API r\u00e9active, d'un worker asynchrone pour l'ingestion de donn\u00e9es, et d'une stack AI multi-fournisseurs.</p> <pre><code>graph TD\n    User([Utilisateur]) &lt;--&gt; Frontend[Frontend Vue.js/Quasar]\n    Frontend &lt;--&gt; API[FastAPI Backend]\n\n    API &lt;--&gt; Postgres[(PostgreSQL)]\n    API &lt;--&gt; Redis[(Redis Cache)]\n    API &lt;--&gt; Qdrant[(Qdrant Vector DB)]\n\n    API -- WebSocket triggers --&gt; Worker[Background Worker]\n    Worker -- Ingestion --&gt; Postgres\n    Worker -- Vectorization --&gt; Qdrant\n\n    API -- LLM/Embed --&gt; AI[Gemini / OpenAI / Mistral]\n    Worker -- Embeddings --&gt; AI\n\n    API -- Tracing --&gt; Phoenix[Arize Phoenix]\n</code></pre>"},{"location":"architecture/#composants-principaux","title":"Composants Principaux","text":""},{"location":"architecture/#1-backend-api-fastapi","title":"1. Backend API (FastAPI)","text":"<p>Le c\u0153ur du syst\u00e8me, responsable de l'orchestration en temps r\u00e9el :</p> <ul> <li>Gestion des Sessions : Authentification et historique des conversations.</li> <li>Orchestration RAG : Int\u00e9gration avec LlamaIndex pour le d\u00e9coupage, l'indexation et la recherche.</li> <li>WebSocket Manager : Diffusion en temps r\u00e9el des r\u00e9ponses et des \u00e9tats de synchronisation.</li> <li>S\u00e9mantique Cache : Utilisation de Redis pour stocker les r\u00e9sultats des requ\u00eates similaires et r\u00e9duire la latence/co\u00fbts.</li> </ul>"},{"location":"architecture/#2-background-worker","title":"2. Background Worker","text":"<p>Un service autonome d\u00e9di\u00e9 aux t\u00e2ches lourdes :</p> <ul> <li>Ingestion Multi-Source : Scan et extraction de donn\u00e9es depuis diverses sources (Connecteurs).</li> <li>Pipeline de Vectorisation : Transformation documentaire en vecteurs via les mod\u00e8les d'embedding (Gemini 004).</li> <li>Synchronisation Temps R\u00e9el : Connect\u00e9 \u00e0 l'API via WebSocket pour r\u00e9agir instantan\u00e9ment aux demandes de l'utilisateur.</li> </ul>"},{"location":"architecture/#3-couche-de-persistance","title":"3. Couche de Persistance","text":"<ul> <li>PostgreSQL : Stocke les m\u00e9tadonn\u00e9es, les configurations des connecteurs et la structure documentaire.</li> <li>Qdrant : Base de donn\u00e9es vectorielle haute performance pour la recherche s\u00e9mantique ultra-rapide.</li> <li>Redis : Cache s\u00e9mantique et stockage temporaire.</li> </ul>"},{"location":"architecture/#4-intelligence-artificielle","title":"4. Intelligence Artificielle","text":"<p>Vectra est \"Model Agnostic\" mais optimis\u00e9 pour la suite Google Cloud :</p> <ul> <li>Mod\u00e8les de Chat : Gemini 1.5 Pro/Flash pour le raisonnement complexe.</li> <li>Embeddings : Gemini Text Embedding 004 pour une repr\u00e9sentation s\u00e9mantique state-of-the-art.</li> <li>Reranking : Utilisation de mod\u00e8les de reranking pour affiner la pertinence des r\u00e9sultats.</li> </ul>"},{"location":"architecture/#flux-de-donnees-rag","title":"Flux de Donn\u00e9es (RAG)","text":"<ol> <li>Requ\u00eate : L'utilisateur pose une question via le frontend.</li> <li>Cache : L'API v\u00e9rifie dans Redis si une question similaire a d\u00e9j\u00e0 \u00e9t\u00e9 trait\u00e9e.</li> <li>Retrieval : Si non, Vectra interroge Qdrant pour extraire les passages les plus pertinents.</li> <li>Augmentation : Le contexte extrait est inject\u00e9 dans le prompt de l'LLM.</li> <li>G\u00e9n\u00e9ration : L'LLM g\u00e9n\u00e8re une r\u00e9ponse sourc\u00e9e et pr\u00e9cise.</li> <li>Streaming : La r\u00e9ponse est renvoy\u00e9e par morceaux (chunks) via WebSocket pour une exp\u00e9rience utilisateur fluide.</li> </ol>"},{"location":"architecture/#observabilite","title":"Observabilit\u00e9","text":"<p>Le syst\u00e8me int\u00e8gre Arize Phoenix via le protocole OpenInference, permettant de tracer chaque \u00e9tape d'une requ\u00eate RAG, d'analyser la latence et de monitorer la qualit\u00e9 des r\u00e9ponses.</p>"},{"location":"config/","title":"Configuration","text":"<p>Vectra utilise des variables d'environnement. Copiez le fichier <code>.env.example</code> vers <code>.env</code> et remplissez-le.</p> <pre><code>GEMINI_API_KEY=votre_clef\n</code></pre>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#prerequis","title":"Pr\u00e9requis","text":"<ul> <li>Python 3.10+</li> <li>Un environnement virtuel</li> </ul>"},{"location":"install/#etapes","title":"\u00c9tapes","text":"<ol> <li>Cloner le repo.</li> <li>Installer les d\u00e9pendances :    <pre><code>pip install -r requirements.txt\n</code></pre></li> </ol>"},{"location":"api/v1/analytics/","title":"Analytics","text":"<p>Advanced Analytics API Endpoints.</p>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.broadcast_analytics_loop","title":"<code>broadcast_analytics_loop(interval_seconds=10)</code>  <code>async</code>","text":"<p>Background task that periodically broadcasts advanced analytics stats via WebSocket.</p> <p>Parameters:</p> <ul> <li> <code>interval_seconds</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Broadcast interval in seconds (default: 10).               Higher than dashboard stats due to query complexity.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>async def broadcast_analytics_loop(interval_seconds: int = 10) -&gt; None:\n    \"\"\"\n    Background task that periodically broadcasts advanced analytics stats via WebSocket.\n\n    Args:\n        interval_seconds: Broadcast interval in seconds (default: 10).\n                          Higher than dashboard stats due to query complexity.\n    \"\"\"\n    global _broadcast_running\n    _broadcast_running = True\n\n    logger.info(f\"Starting advanced analytics broadcast loop (interval: {interval_seconds}s)\")\n\n    from app.core.connection_manager import manager\n    from app.core.database import SessionLocal\n\n    while _broadcast_running:\n        try:\n            # P0 Fix: Pass the factory, not a session, to support parallel execution inside loop\n            factory = get_session_factory()\n            # Initialize SettingsService (no DB session needed for advanced analytics as they use defaults/env)\n            settings_service = SettingsService(db=None)\n            service = AnalyticsService(session_factory=factory, settings_service=settings_service)\n\n            # Use standard defaults for the live view\n            stats = await service.get_all_advanced_analytics(\n                ttft_hours=24, step_days=7, cache_hours=24, cost_hours=24, trending_limit=10\n            )\n\n            # Broadcast via WebSocket\n            await manager.emit_advanced_analytics_stats(stats.model_dump(mode=\"json\"))\n\n        except Exception as e:\n            logger.error(f\"Error in analytics broadcast: {e}\", exc_info=True)\n\n        # Wait for next interval\n        await asyncio.sleep(interval_seconds)\n\n    logger.info(\"Advanced analytics broadcast loop stopped\")\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_advanced_analytics","title":"<code>get_advanced_analytics(service, assistant_id=Query(None, description='Filter by assistant ID'), ttft_hours=Query(24, ge=1, le=168, description='TTFT analysis period in hours'), step_days=Query(7, ge=1, le=90, description='Step breakdown period in days'), cache_hours=Query(24, ge=1, le=168, description='Cache metrics period in hours'), cost_hours=Query(24, ge=1, le=168, description='Cost analysis period in hours'), trending_limit=Query(10, ge=1, le=50, description='Number of trending topics'))</code>  <code>async</code>","text":"<p>Get comprehensive advanced analytics for the admin dashboard.</p> <p>Returns: - TTFT percentiles (p50, p95, p99) - Pipeline step breakdown - Cache hit rate - Trending topics - Topic diversity score - Assistant token costs - Document freshness</p> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/advanced\", response_model=AdvancedAnalyticsResponse)\nasync def get_advanced_analytics(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n    assistant_id: Optional[UUID] = Query(None, description=\"Filter by assistant ID\"),\n    ttft_hours: int = Query(24, ge=1, le=168, description=\"TTFT analysis period in hours\"),\n    step_days: int = Query(7, ge=1, le=90, description=\"Step breakdown period in days\"),\n    cache_hours: int = Query(24, ge=1, le=168, description=\"Cache metrics period in hours\"),\n    cost_hours: int = Query(24, ge=1, le=168, description=\"Cost analysis period in hours\"),\n    trending_limit: int = Query(10, ge=1, le=50, description=\"Number of trending topics\"),\n) -&gt; AdvancedAnalyticsResponse:\n    \"\"\"\n    Get comprehensive advanced analytics for the admin dashboard.\n\n    Returns:\n    - TTFT percentiles (p50, p95, p99)\n    - Pipeline step breakdown\n    - Cache hit rate\n    - Trending topics\n    - Topic diversity score\n    - Assistant token costs\n    - Document freshness\n    \"\"\"\n    return await service.get_all_advanced_analytics(\n        ttft_hours=ttft_hours,\n        step_days=step_days,\n        cache_hours=cache_hours,\n        cost_hours=cost_hours,\n        trending_limit=trending_limit,\n        assistant_id=assistant_id,\n    )\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_assistant_costs","title":"<code>get_assistant_costs(service, hours=Query(24, ge=1, le=168, description='Analysis period in hours'))</code>  <code>async</code>","text":"<p>Get token costs by assistant.</p> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/costs\", response_model=list[AssistantCost])\nasync def get_assistant_costs(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n    hours: int = Query(24, ge=1, le=168, description=\"Analysis period in hours\"),\n):\n    \"\"\"Get token costs by assistant.\"\"\"\n    return await service.get_assistant_costs(hours)\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_document_freshness","title":"<code>get_document_freshness(service)</code>  <code>async</code>","text":"<p>Get knowledge base document freshness distribution.</p> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/freshness\", response_model=list[DocumentFreshness])\nasync def get_document_freshness(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n):\n    \"\"\"Get knowledge base document freshness distribution.\"\"\"\n    return await service.get_document_freshness()\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_trending_topics","title":"<code>get_trending_topics(service, assistant_id=Query(None, description='Filter by assistant ID'), limit=Query(10, ge=1, le=50, description='Number of topics to return'))</code>  <code>async</code>","text":"<p>Get top trending questions/topics.</p> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/trending\", response_model=list[TrendingTopic])\nasync def get_trending_topics(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n    assistant_id: Optional[UUID] = Query(None, description=\"Filter by assistant ID\"),\n    limit: int = Query(10, ge=1, le=50, description=\"Number of topics to return\"),\n):\n    \"\"\"Get top trending questions/topics.\"\"\"\n    return await service.get_trending_topics(assistant_id, limit)\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_ttft_percentiles","title":"<code>get_ttft_percentiles(service, hours=Query(24, ge=1, le=168, description='Analysis period in hours'))</code>  <code>async</code>","text":"<p>Get Time-to-First-Token percentiles.</p> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/ttft\", response_model=TTFTPercentiles)\nasync def get_ttft_percentiles(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n    hours: int = Query(24, ge=1, le=168, description=\"Analysis period in hours\"),\n):\n    \"\"\"Get Time-to-First-Token percentiles.\"\"\"\n    result = await service.get_ttft_percentiles(hours)\n\n    if not result:\n        return TTFTPercentiles(p50=0, p95=0, p99=0, period_hours=hours)\n\n    return result\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.start_broadcast_task","title":"<code>start_broadcast_task(interval_seconds=10)</code>  <code>async</code>","text":"<p>Start the periodic broadcast background task.</p> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>async def start_broadcast_task(interval_seconds: int = 10) -&gt; None:\n    \"\"\"Start the periodic broadcast background task.\"\"\"\n    global _broadcast_task, _broadcast_running\n\n    if _broadcast_task is not None and not _broadcast_task.done():\n        logger.warning(\"Analytics broadcast task already running\")\n        return\n\n    _broadcast_running = True\n    _broadcast_task = asyncio.create_task(broadcast_analytics_loop(interval_seconds))\n    logger.info(\"Analytics broadcast task started\")\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.stop_broadcast_task","title":"<code>stop_broadcast_task()</code>  <code>async</code>","text":"<p>Stop the periodic broadcast background task.</p> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>async def stop_broadcast_task() -&gt; None:\n    \"\"\"Stop the periodic broadcast background task.\"\"\"\n    global _broadcast_task, _broadcast_running\n\n    if _broadcast_task is None:\n        return\n\n    _broadcast_running = False\n\n    # Wait for task to finish\n    try:\n        await asyncio.wait_for(_broadcast_task, timeout=10.0)\n    except asyncio.TimeoutError:\n        logger.warning(\"Analytics broadcast task did not stop gracefully, cancelling\")\n        _broadcast_task.cancel()\n\n    _broadcast_task = None\n    logger.info(\"Analytics broadcast task stopped\")\n</code></pre>"},{"location":"api/v1/assistants/","title":"Assistants","text":""},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.clear_assistant_cache","title":"<code>clear_assistant_cache(assistant_id, service, current_user)</code>  <code>async</code>","text":"<p>Manually purge the semantic cache for a specific assistant. Useful when documents are updated or LLM instructions change.</p> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.delete(\"/{assistant_id}/cache\", response_model=Dict[str, int])\nasync def clear_assistant_cache(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"\n    Manually purge the semantic cache for a specific assistant.\n    Useful when documents are updated or LLM instructions change.\n    \"\"\"\n    try:\n        count = await service.clear_cache(assistant_id)\n        return {\"deleted_count\": count}\n    except Exception as e:\n        logger.error(f\"Failed to clear cache for assistant {assistant_id}: {e}\", exc_info=True)\n        if isinstance(e, (FunctionalError, TechnicalError)):\n            raise\n        raise TechnicalError(f\"Failed to clear cache: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.create_assistant","title":"<code>create_assistant(assistant, service, current_user)</code>  <code>async</code>","text":"<p>Create a new assistant (Admin only).</p> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.post(\"/\", response_model=AssistantResponse, status_code=status.HTTP_201_CREATED)\nasync def create_assistant(\n    assistant: AssistantCreate,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Create a new assistant (Admin only).\"\"\"\n    try:\n        return await service.create_assistant(assistant)\n    except Exception as e:\n        logger.error(f\"Failed to create assistant: {e}\", exc_info=True)\n        if isinstance(e, (FunctionalError, TechnicalError)):\n            raise\n        raise TechnicalError(f\"Failed to create assistant: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.delete_assistant","title":"<code>delete_assistant(assistant_id, service, current_user)</code>  <code>async</code>","text":"<p>Delete an assistant (Admin only).</p> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.delete(\"/{assistant_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_assistant(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Delete an assistant (Admin only).\"\"\"\n    try:\n        success = await service.delete_assistant(assistant_id)\n        if not success:\n            raise EntityNotFound(\"Assistant not found\")\n        return  # 204 No Content\n    except EntityNotFound:\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to delete assistant {assistant_id}: {e}\", exc_info=True)\n        raise TechnicalError(f\"Failed to delete assistant: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.delete_assistant_avatar","title":"<code>delete_assistant_avatar(assistant_id, service, current_user)</code>  <code>async</code>","text":"<p>Remove the avatar image from the assistant.</p> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.delete(\"/{assistant_id}/avatar\", response_model=AssistantResponse)\nasync def delete_assistant_avatar(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Remove the avatar image from the assistant.\"\"\"\n    try:\n        return await service.remove_avatar(assistant_id)\n    except Exception as e:\n        logger.error(f\"Failed to remove avatar: {e}\", exc_info=True)\n        if isinstance(e, (FunctionalError, TechnicalError)):\n            raise\n        raise TechnicalError(f\"Failed to remove avatar: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.get_assistant","title":"<code>get_assistant(assistant_id, service, user)</code>  <code>async</code>","text":"<p>Get a single assistant by ID.</p> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.get(\"/{assistant_id}\", response_model=AssistantResponse)\nasync def get_assistant(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    user: Annotated[Optional[User], Depends(get_current_user_optional)],\n):\n    \"\"\"Get a single assistant by ID.\"\"\"\n    try:\n        assistant = await service.get_assistant(assistant_id)\n        if not assistant:\n            raise EntityNotFound(\"Assistant not found\")\n\n        # Access Control: If assistant requires authentication, user must be logged in.\n        if assistant.user_authentication and not user:\n            logger.warning(f\"Access denied for assistant {assistant_id}: User Authentication Required\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Authentication required for this assistant\"\n            )\n\n        return assistant\n\n    except (EntityNotFound, HTTPException):\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to fetch assistant {assistant_id}: {e}\", exc_info=True)\n        raise TechnicalError(f\"Failed to fetch assistant: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.get_assistant_avatar","title":"<code>get_assistant_avatar(assistant_id, service, user)</code>  <code>async</code>","text":"<p>Get the avatar image file.</p> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.get(\"/{assistant_id}/avatar\")\nasync def get_assistant_avatar(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    user: Annotated[Optional[User], Depends(get_current_user_optional)],\n):\n    \"\"\"Get the avatar image file.\"\"\"\n    try:\n        # P0: Check Access Control before serving file\n        # Retrieve assistant first (lightweight DB fetch)\n        assistant = await service.get_assistant(assistant_id)\n        if not assistant:\n            raise EntityNotFound(\"Avatar not found\")  # Or Assistant not found\n\n        if assistant.user_authentication and not user:\n            # Private assistant -&gt; Private avatar\n            raise HTTPException(status_code=404, detail=\"Avatar not found\")  # Obfuscate existence\n\n        file_path = await service.get_avatar_path(assistant_id)\n        if not file_path:\n            raise EntityNotFound(\"Avatar not found\")\n\n        return FileResponse(file_path)\n    except EntityNotFound:\n        raise HTTPException(status_code=404, detail=\"Avatar not found\")\n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to get avatar: {e}\", exc_info=True)\n        raise TechnicalError(f\"Failed to get avatar: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.get_assistants","title":"<code>get_assistants(service, user, skip=Query(0, ge=0), limit=Query(100, ge=1, le=1000))</code>  <code>async</code>","text":"<p>List all assistants. Public access allowed but filtered for Guests.</p> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.get(\"/\", response_model=List[AssistantResponse])\nasync def get_assistants(\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    user: Annotated[Optional[User], Depends(get_current_user_optional)],\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n):\n    \"\"\"\n    List all assistants.\n    Public access allowed but filtered for Guests.\n    \"\"\"\n    # Filter: If User is missing (Guest), exclude private assistants.\n    exclude_private = user is None\n\n    try:\n        # TODO: Refactor Service to support DB-side pagination (P1)\n        # Passing exclude_private to service layer\n        assistants = await service.get_assistants(exclude_private=exclude_private)\n\n        # Manual Slicing (Temporary P2 solution)\n        return assistants[skip : skip + limit]\n\n    except Exception as e:\n        logger.error(f\"Failed to fetch assistants: {e}\", exc_info=True)\n        raise TechnicalError(f\"Failed to fetch assistants: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.update_assistant","title":"<code>update_assistant(assistant_id, assistant, service, current_user)</code>  <code>async</code>","text":"<p>Update an existing assistant (Admin only).</p> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.put(\"/{assistant_id}\", response_model=AssistantResponse)\nasync def update_assistant(\n    assistant_id: UUID,\n    assistant: AssistantUpdate,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Update an existing assistant (Admin only).\"\"\"\n    try:\n        updated_assistant = await service.update_assistant(assistant_id, assistant)\n        if not updated_assistant:\n            raise EntityNotFound(\"Assistant not found\")\n        return updated_assistant\n    except EntityNotFound:\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to update assistant {assistant_id}: {e}\", exc_info=True)\n        if isinstance(e, (FunctionalError, TechnicalError)):\n            raise\n        raise TechnicalError(f\"Failed to update assistant: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.upload_assistant_avatar","title":"<code>upload_assistant_avatar(assistant_id, file=File(...), service=None, current_user=None)</code>  <code>async</code>","text":"<p>Upload an avatar image for the assistant.</p> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.post(\"/{assistant_id}/avatar\", response_model=AssistantResponse)\nasync def upload_assistant_avatar(\n    assistant_id: UUID,\n    file: UploadFile = File(...),\n    service: Annotated[AssistantService, Depends(get_assistant_service)] = None,\n    current_user: Annotated[User, Depends(get_current_admin)] = None,\n):\n    \"\"\"Upload an avatar image for the assistant.\"\"\"\n    try:\n        # P0: Security Check - Ensure assistant exists implicitly via Service,\n        # but explicit check helps return 404 cleanly before processing file.\n        # Service handles this update logic internally via DB constraint or check.\n        return await service.upload_avatar(assistant_id, file)\n    except Exception as e:\n        logger.error(f\"Failed to upload avatar: {e}\", exc_info=True)\n        if isinstance(e, (FunctionalError, TechnicalError)):\n            raise\n        raise TechnicalError(f\"Failed to upload avatar: {e}\")\n</code></pre>"},{"location":"api/v1/chat/","title":"Chat","text":""},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.chat_stream","title":"<code>chat_stream(request, chat_service, assistant_service, user)</code>  <code>async</code>","text":"<p>Stream chat response for a session. Supports SSE (Server-Sent Events) via NDJSON or text/event-stream.</p> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.post(\"/stream\")\nasync def chat_stream(\n    request: ChatRequest,\n    chat_service: Annotated[ChatService, Depends(get_chat_service)],\n    assistant_service: Annotated[AssistantService, Depends(get_assistant_service)],\n    user: Annotated[Optional[User], Depends(get_optional_user)],\n):\n    \"\"\"\n    Stream chat response for a session.\n    Supports SSE (Server-Sent Events) via NDJSON or text/event-stream.\n    \"\"\"\n    try:\n        # 1. Fetch Assistant (raw SQLAlchemy model for ChatService)\n        assistant_uuid = request.assistant_id\n        assistant = await assistant_service.get_assistant_model(assistant_uuid)\n        if not assistant:\n            raise EntityNotFound(\"Assistant not found\")\n\n        # 2. Authorization Check\n        user_id = str(user.id) if user else None\n        if assistant.user_authentication and not user_id:\n            logger.warning(f\"Access denied for assistant {assistant.id}: User Authentication Required\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Authentication required for this assistant\"\n            )\n\n        # 3. Stream\n        logger.info(f\"Init Chat Stream | Session: {request.session_id} | User: {user_id}\")\n\n        # Standard RAG Stream (with Vanna routing via SQL connector type)\n        return StreamingResponse(\n            chat_service.stream_chat(\n                request.message,\n                assistant,\n                request.session_id,\n                language=request.language,\n                history=request.history,\n                user_id=user_id,\n            ),\n            media_type=\"application/x-ndjson\",\n        )\n\n    except (FunctionalError, EntityNotFound, HTTPException):\n        raise\n    except Exception as e:\n        logger.error(f\"Chat stream initialization failed: {e}\", exc_info=True)\n        raise TechnicalError(f\"Chat stream initialization failed: {e}\")\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.debug_stream","title":"<code>debug_stream(request, chat_service, assistant_service, user)</code>  <code>async</code>","text":"<p>Debug version that returns full exceptions</p> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.post(\"/debug-stream\")\nasync def debug_stream(\n    request: ChatRequest,\n    chat_service: Annotated[ChatService, Depends(get_chat_service)],\n    assistant_service: Annotated[AssistantService, Depends(get_assistant_service)],\n    user: Annotated[Optional[User], Depends(get_optional_user)],\n):\n    \"\"\"Debug version that returns full exceptions\"\"\"\n    import traceback\n\n    try:\n        assistant_uuid = request.assistant_id\n        assistant = await assistant_service.get_assistant_model(assistant_uuid)\n        if not assistant:\n            return {\"error\": \"Assistant not found\"}\n\n        user_id = str(user.id) if user else None\n\n        # Try to get first event\n        async for event in chat_service.stream_chat(\n            request.message,\n            assistant,\n            request.session_id,\n            language=request.language,\n            history=request.history,\n            user_id=user_id,\n        ):\n            return {\"success\": True, \"first_event\": event[:200]}\n    except Exception as e:\n        return {\"error\": str(e), \"type\": type(e).__name__, \"traceback\": traceback.format_exc()}\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.get_chat_history","title":"<code>get_chat_history(session_id, chat_service, user)</code>  <code>async</code>","text":"<p>Retrieve conversation history for a specific session ID.</p> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.get(\"/{session_id}/history\")\nasync def get_chat_history(\n    session_id: str,\n    chat_service: Annotated[ChatService, Depends(get_chat_service)],\n    user: Annotated[Optional[User], Depends(get_optional_user)],\n):\n    \"\"\"Retrieve conversation history for a specific session ID.\"\"\"\n    try:\n        # Get history from the chat repository (Postgres) instead of Redis for full persistence\n        messages = await chat_service.chat_repository.get_messages(session_id)\n\n        # Transform to frontend-compatible format\n        formatted_messages = []\n        for idx, msg in enumerate(messages):\n            m = {\n                \"id\": str(msg.id),  # Use actual message UUID\n                \"text\": msg.content,\n                \"sender\": \"user\" if msg.role == \"user\" else \"bot\",\n            }\n            # Include metadata (visualization, sources, etc.)\n            # Include metadata (visualization, sources, etc.)\n            if msg.metadata_:\n                meta = msg.metadata_.copy()\n\n                # Format Sources for Frontend (Source[] interface)\n                if \"sources\" in meta and isinstance(meta[\"sources\"], list):\n                    formatted_sources = []\n                    for s in meta[\"sources\"]:\n                        # Map backend 'file_name' in metadata to frontend 'name'\n                        s_meta = s.get(\"metadata\", {})\n                        file_name = s_meta.get(\"file_name\") or s_meta.get(\"filename\") or s_meta.get(\"name\") or \"Unknown\"\n\n                        # Type detection (simplified)\n                        s_type = \"txt\"\n                        lower = file_name.lower()\n                        if lower.endswith(\".pdf\"):\n                            s_type = \"pdf\"\n                        elif lower.endswith(\".docx\"):\n                            s_type = \"docx\"\n\n                        formatted_sources.append(\n                            {\n                                \"id\": s.get(\"id\"),\n                                \"name\": file_name,\n                                \"type\": s_type,\n                                \"content\": s.get(\"text\"),\n                                \"metadata\": s_meta,\n                            }\n                        )\n                    meta[\"sources\"] = formatted_sources\n\n                # Format Steps (Ensure labels are present)\n                if \"steps\" in meta and isinstance(meta[\"steps\"], list):\n                    valid_steps = []\n                    for step in meta[\"steps\"]:\n                        # Filter out steps with no label and no meaningful data\n                        if not step.get(\"label\"):\n                            # Try to infer label from step_type\n                            stype = step.get(\"step_type\", \"unknown\")\n                            step[\"label\"] = stype.replace(\"_\", \" \").title()\n\n                        # Map nesting metadata (backend 'is_substep' -&gt; frontend 'isSubStep')\n                        step_meta = step.get(\"metadata\", {})\n                        if step_meta.get(\"is_substep\") or step_meta.get(\"isSubStep\"):\n                            step[\"isSubStep\"] = True\n\n                        # Clean up backend-specific large dicts if needed, or just pass through\n                        valid_steps.append(step)\n                    meta[\"steps\"] = valid_steps\n\n                # Format Visualization (Repair types if stringified by sanitization)\n                if \"visualization\" in meta and meta[\"visualization\"]:\n                    viz = meta[\"visualization\"]\n                    # Ensure Series is a List\n                    if \"series\" in viz and isinstance(viz[\"series\"], list):\n                        for s in viz[\"series\"]:\n                            # Handle Treemap/Hierarchical Data (x, y dicts)\n                            if isinstance(s, dict) and \"data\" in s and isinstance(s[\"data\"], list):\n                                for point in s[\"data\"]:\n                                    if isinstance(point, dict) and \"y\" in point:\n                                        try:\n                                            # Force to float if it's a string\n                                            point[\"y\"] = float(point[\"y\"])\n                                        except (ValueError, TypeError):\n                                            point[\"y\"] = 0.0\n                            # Handle standard Cartesian/Pie (simple value list)\n                            elif isinstance(s, (int, float, str)):\n                                # For Pie charts, series is just a list of values, but here we iterate over viz[\"series\"]\n                                # If viz[\"series\"] is [10, 20], then 's' is 10. We can't modify 's' in-place easily if it's a primitive.\n                                # But format_circular sets 'series' to a list of values.\n                                pass\n\n                        # Fix for simple value lists (Pie/Donut) being stringified\n                        if viz.get(\"viz_type\") in [\"pie\", \"donut\", \"polarArea\", \"radialBar\"]:\n                            try:\n                                viz[\"series\"] = [float(x) for x in viz[\"series\"]]\n                            except Exception:\n                                pass\n\n                m.update(meta)\n\n            formatted_messages.append(m)\n\n        return {\"messages\": formatted_messages}\n    except Exception as e:\n        logger.error(f\"Failed to retrieve history for session {session_id}: {e}\", exc_info=True)\n        # Don't fail hard - return empty history on error\n        return {\"messages\": []}\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.get_optional_user","title":"<code>get_optional_user(request, db)</code>  <code>async</code>","text":"<p>Resolves user from Bearer token if present, otherwise returns None. Does not raise 401 for invalid tokens, just returns None (for public access if allowed).</p> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>async def get_optional_user(request: Request, db: Annotated[AsyncSession, Depends(get_db)]) -&gt; Optional[User]:\n    \"\"\"\n    Resolves user from Bearer token if present, otherwise returns None.\n    Does not raise 401 for invalid tokens, just returns None (for public access if allowed).\n    \"\"\"\n    auth_header = request.headers.get(\"Authorization\")\n    if auth_header and auth_header.startswith(\"Bearer \"):\n        token = auth_header.split(\" \")[1]\n        try:\n            return await get_current_user(token=token, db=db)\n        except Exception:\n            return None\n    return None\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.ping","title":"<code>ping()</code>  <code>async</code>","text":"<p>Minimal test endpoint with zero dependencies</p> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.get(\"/ping\")\nasync def ping():\n    \"\"\"Minimal test endpoint with zero dependencies\"\"\"\n    return {\"status\": \"ok\", \"message\": \"Backend is alive\"}\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.reset_chat_session","title":"<code>reset_chat_session(session_id, chat_service)</code>  <code>async</code>","text":"<p>Resets the conversation history for a specific session ID.</p> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.delete(\"/{session_id}\")\nasync def reset_chat_session(session_id: str, chat_service: Annotated[ChatService, Depends(get_chat_service)]):\n    \"\"\"Resets the conversation history for a specific session ID.\"\"\"\n    try:\n        await chat_service.reset_conversation(session_id)\n\n        return {\"message\": \"Conversation history reset successfully\"}\n    except Exception as e:\n        logger.error(f\"Failed to reset conversation {session_id}: {e}\", exc_info=True)\n        if isinstance(e, (TechnicalError, FunctionalError)):\n            raise\n        raise TechnicalError(f\"Failed to reset conversation: {e}\")\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.test_assistant_svc","title":"<code>test_assistant_svc(assistant_service)</code>  <code>async</code>","text":"<p>Test if AssistantService injection works</p> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.get(\"/test-assistant-service\")\nasync def test_assistant_svc(assistant_service: Annotated[AssistantService, Depends(get_assistant_service)]):\n    \"\"\"Test if AssistantService injection works\"\"\"\n    return {\"status\": \"ok\", \"service\": \"injected\"}\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.test_db","title":"<code>test_db(db)</code>  <code>async</code>","text":"<p>Test if DB injection works</p> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.get(\"/test-db\")\nasync def test_db(db: Annotated[AsyncSession, Depends(get_db)]):\n    \"\"\"Test if DB injection works\"\"\"\n    return {\"status\": \"ok\", \"db\": \"connected\"}\n</code></pre>"},{"location":"api/v1/connectors/","title":"Connectors","text":""},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.create_connector","title":"<code>create_connector(connector, service, current_user)</code>  <code>async</code>","text":"<p>Create a new connector.</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/\", response_model=ConnectorResponse)\nasync def create_connector(\n    connector: ConnectorCreate,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Create a new connector.\"\"\"\n    return await service.create_connector(connector)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.create_connector_document","title":"<code>create_connector_document(connector_id, document, service, current_user)</code>  <code>async</code>","text":"<p>Manually add a document to a connector.</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/documents\", response_model=ConnectorDocumentResponse)\nasync def create_connector_document(\n    connector_id: UUID,\n    document: ConnectorDocumentCreate,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Manually add a document to a connector.\"\"\"\n    return await service.create_document(connector_id, document)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.delete_connector","title":"<code>delete_connector(connector_id, service, current_user)</code>  <code>async</code>","text":"<p>Delete a connector and its resources.</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.delete(\"/{connector_id}\")\nasync def delete_connector(\n    connector_id: UUID,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Delete a connector and its resources.\"\"\"\n    await service.delete_connector(connector_id)\n    return {\"message\": \"Connector deleted successfully\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.delete_document","title":"<code>delete_document(connector_id, document_id, service, current_user)</code>  <code>async</code>","text":"<p>Delete a specific document.</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.delete(\"/{connector_id}/documents/{document_id}\")\nasync def delete_document(\n    connector_id: UUID,\n    document_id: UUID,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Delete a specific document.\"\"\"\n    await service.delete_document(document_id)\n    return {\"message\": \"Document deleted successfully\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.get_connector_documents","title":"<code>get_connector_documents(connector_id, service, current_user, page=1, size=20, status=None, search=None)</code>  <code>async</code>","text":"<p>Get paginated documents for a connector.</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.get(\"/{connector_id}/documents\", response_model=Dict[str, Any])\nasync def get_connector_documents(\n    connector_id: UUID,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n    page: int = 1,\n    size: int = 20,\n    status: Optional[DocStatus] = None,\n    search: Optional[str] = None,\n):\n    \"\"\"Get paginated documents for a connector.\"\"\"\n    result = await service.get_connector_documents(connector_id, page, size, status, search)\n    result[\"items\"] = [ConnectorDocumentResponse.model_validate(doc) for doc in result[\"items\"]]\n    return result\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.get_connectors","title":"<code>get_connectors(service, current_user)</code>  <code>async</code>","text":"<p>List all connectors.</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.get(\"/\", response_model=List[ConnectorResponse])\nasync def get_connectors(\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"List all connectors.\"\"\"\n    return await service.get_connectors()\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.scan_connector_files","title":"<code>scan_connector_files(connector_id, service, current_user)</code>  <code>async</code>","text":"<p>Trigger manual file scan for a folder connector.</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/scan-files/\", response_model=ConnectorResponse)\n@router.post(\"/{connector_id}/scan-files\", response_model=ConnectorResponse)\nasync def scan_connector_files(\n    connector_id: UUID,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Trigger manual file scan for a folder connector.\"\"\"\n    return await service.scan_connector(connector_id)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.stop_connector","title":"<code>stop_connector(connector_id, service, current_user)</code>  <code>async</code>","text":"<p>Request to stop a running connector sync.</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/stop\", response_model=ConnectorResponse)\nasync def stop_connector(\n    connector_id: UUID,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Request to stop a running connector sync.\"\"\"\n    return await service.stop_connector(connector_id)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.stop_document","title":"<code>stop_document(connector_id, document_id, service, current_user)</code>  <code>async</code>","text":"<p>Request to stop re-sync for a single document.</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/documents/{document_id}/stop\")\nasync def stop_document(\n    connector_id: UUID,\n    document_id: UUID,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Request to stop re-sync for a single document.\"\"\"\n    await service.stop_document(document_id)\n    return {\"message\": \"Document sync stop requested\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.sync_connector","title":"<code>sync_connector(connector_id, service, current_user, force=False)</code>  <code>async</code>","text":"<p>Trigger manual synchronization for a connector.</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/sync\", response_model=ConnectorResponse)\nasync def sync_connector(\n    connector_id: UUID,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n    force: bool = False,\n):\n    \"\"\"Trigger manual synchronization for a connector.\"\"\"\n    connector = await service.trigger_sync(connector_id, force)\n    await manager.emit_trigger_connector_sync(str(connector_id))\n    return connector\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.sync_document","title":"<code>sync_document(connector_id, document_id, service, current_user)</code>  <code>async</code>","text":"<p>Trigger re-sync for a single document.</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/documents/{document_id}/sync\")\nasync def sync_document(\n    connector_id: UUID,\n    document_id: UUID,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Trigger re-sync for a single document.\"\"\"\n    await service.sync_document(document_id)\n    return {\"message\": \"Document sync queued\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.test_connection","title":"<code>test_connection(payload, service, sql_discovery_service, current_user)</code>  <code>async</code>","text":"<p>Test a connector connection (primarily for SQL).</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/test-connection\")\nasync def test_connection(\n    payload: Dict[str, Any],\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    sql_discovery_service: Annotated[Any, Depends(get_sql_discovery_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Test a connector connection (primarily for SQL).\"\"\"\n    connector_type = payload.get(\"connector_type\")\n    configuration = payload.get(\"configuration\")\n\n    if not connector_type or not configuration:\n        return {\"success\": False, \"message\": \"Missing connector_type or configuration\"}\n\n    if connector_type in [\"sql\", \"vanna_sql\"]:\n        try:\n            await sql_discovery_service.test_connection(configuration)\n            return {\"success\": True, \"message\": \"Connection successful\"}\n        except Exception as e:\n            return {\"success\": False, \"message\": str(e)}\n\n    # Add other types if needed\n    return {\"success\": False, \"message\": f\"Connection test not implemented for {connector_type}\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.train_vanna_connector","title":"<code>train_vanna_connector(connector_id, payload, service, document_service, current_user)</code>  <code>async</code>","text":"<p>Train Vanna AI on specific documents (tables/views) for vanna_sql connector.</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/train\")\nasync def train_vanna_connector(\n    connector_id: UUID,\n    payload: Dict[str, Any],\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    document_service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Train Vanna AI on specific documents (tables/views) for vanna_sql connector.\"\"\"\n    import asyncio\n    from datetime import datetime\n\n    from app.services.chat.vectra_vanna_service import VannaServiceFactory\n\n    document_ids = payload.get(\"document_ids\", [])\n    if not document_ids:\n        return {\"success\": False, \"message\": \"document_ids array is required\"}\n\n    # Load connector\n    connector = await service.get_connector(connector_id)\n    if not connector:\n        return {\"success\": False, \"message\": \"Connector not found\"}\n\n    if connector.connector_type != \"vanna_sql\":\n        return {\"success\": False, \"message\": \"Training is only available for vanna_sql connectors\"}\n\n    try:\n        # Initialize Vanna service (Async Factory)\n        vanna_svc = await VannaServiceFactory(service.settings_service)\n\n        trained_count = 0\n        failed_count = 0\n\n        # Train each document\n        for doc_id in document_ids:\n            try:\n                # Get document\n                document = await document_service.get_document(UUID(doc_id) if isinstance(doc_id, str) else doc_id)\n                if not document:\n                    logger.warning(f\"Document {doc_id} not found, skipping\")\n                    failed_count += 1\n                    continue\n\n                # Train Vanna with document's DDL content\n                await asyncio.to_thread(vanna_svc.train, ddl=document.content)\n\n                # Mark as trained in metadata\n                if not document.metadata:\n                    document.metadata = {}\n                document.metadata[\"trained\"] = True\n                document.metadata[\"trained_at\"] = datetime.utcnow().isoformat()\n\n                # Update document\n                from app.schemas.document import DocumentUpdate\n\n                await document_service.update_document(document.id, DocumentUpdate(metadata=document.metadata))\n\n                trained_count += 1\n                logger.info(f\"Trained Vanna on document: {document.name}\")\n\n            except Exception as doc_error:\n                logger.error(f\"Failed to train document {doc_id}: {doc_error}\")\n                failed_count += 1\n\n        return {\n            \"success\": True,\n            \"message\": f\"Training completed. {trained_count} documents trained, {failed_count} failed.\",\n            \"trained_count\": trained_count,\n            \"failed_count\": failed_count,\n        }\n    except Exception as e:\n        logger.error(f\"Training failed: {e}\", exc_info=True)\n        return {\"success\": False, \"message\": f\"Training failed: {str(e)}\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.update_connector","title":"<code>update_connector(connector_id, connector, service, current_user)</code>  <code>async</code>","text":"<p>Update an existing connector.</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.put(\"/{connector_id}\", response_model=ConnectorResponse)\nasync def update_connector(\n    connector_id: UUID,\n    connector: ConnectorUpdate,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Update an existing connector.\"\"\"\n    return await service.update_connector(connector_id, connector)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.update_document","title":"<code>update_document(connector_id, document_id, document, service, current_user)</code>  <code>async</code>","text":"<p>Update a specific document.</p> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.put(\"/{connector_id}/documents/{document_id}\", response_model=ConnectorDocumentResponse)\nasync def update_document(\n    connector_id: UUID,\n    document_id: UUID,\n    document: ConnectorDocumentUpdate,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n):\n    \"\"\"Update a specific document.\"\"\"\n    return await service.update_document(document_id, document)\n</code></pre>"},{"location":"api/v1/dashboard/","title":"Dashboard","text":"<p>Dashboard Statistics API Endpoint.</p> <p>Provides REST endpoint for dashboard stats and manages periodic WebSocket broadcasts.</p>"},{"location":"api/v1/dashboard/#app.api.v1.endpoints.dashboard.broadcast_dashboard_stats_loop","title":"<code>broadcast_dashboard_stats_loop(interval_seconds=5)</code>  <code>async</code>","text":"<p>Background task that periodically broadcasts dashboard stats via WebSocket.</p> <p>Parameters:</p> <ul> <li> <code>interval_seconds</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Broadcast interval in seconds (default: 5)</p> </li> </ul> Source code in <code>app/api/v1/endpoints/dashboard.py</code> <pre><code>async def broadcast_dashboard_stats_loop(interval_seconds: int = 5) -&gt; None:\n    \"\"\"\n    Background task that periodically broadcasts dashboard stats via WebSocket.\n\n    Args:\n        interval_seconds: Broadcast interval in seconds (default: 5)\n    \"\"\"\n    global _broadcast_running\n    _broadcast_running = True\n\n    logger.info(f\"Starting dashboard stats broadcast loop (interval: {interval_seconds}s)\")\n\n    # Import here to avoid circular dependency\n    # Import here to avoid circular dependency\n    from app.core.connection_manager import manager\n    from app.core.database import SessionLocal\n\n    while _broadcast_running:\n        try:\n            # Create a new database session for this iteration\n            async with SessionLocal() as db:\n                service = DashboardStatsService(db)\n                stats = await service.get_all_stats()\n\n                # Broadcast via WebSocket\n                await manager.emit_dashboard_stats(stats.model_dump(mode=\"json\"))\n\n        except Exception as e:\n            logger.error(f\"Error in dashboard stats broadcast: {e}\", exc_info=True)\n\n        # Wait for next interval\n        await asyncio.sleep(interval_seconds)\n\n    logger.info(\"Dashboard stats broadcast loop stopped\")\n</code></pre>"},{"location":"api/v1/dashboard/#app.api.v1.endpoints.dashboard.get_dashboard_stats","title":"<code>get_dashboard_stats(db)</code>  <code>async</code>","text":"<p>Get current dashboard statistics (REST endpoint).</p> <p>This provides a synchronous way to fetch stats without WebSocket.</p> Source code in <code>app/api/v1/endpoints/dashboard.py</code> <pre><code>@router.get(\"/stats\", response_model=DashboardStats)\nasync def get_dashboard_stats(db: Annotated[AsyncSession, Depends(get_db)]) -&gt; DashboardStats:\n    \"\"\"\n    Get current dashboard statistics (REST endpoint).\n\n    This provides a synchronous way to fetch stats without WebSocket.\n    \"\"\"\n    service = DashboardStatsService(db)\n    stats = await service.get_all_stats()\n    return stats\n</code></pre>"},{"location":"api/v1/dashboard/#app.api.v1.endpoints.dashboard.start_broadcast_task","title":"<code>start_broadcast_task(interval_seconds=5)</code>  <code>async</code>","text":"<p>Start the periodic broadcast background task.</p> Source code in <code>app/api/v1/endpoints/dashboard.py</code> <pre><code>async def start_broadcast_task(interval_seconds: int = 5) -&gt; None:\n    \"\"\"Start the periodic broadcast background task.\"\"\"\n    global _broadcast_task, _broadcast_running\n\n    if _broadcast_task is not None and not _broadcast_task.done():\n        logger.warning(\"Dashboard broadcast task already running\")\n        return\n\n    _broadcast_running = True\n    _broadcast_task = asyncio.create_task(broadcast_dashboard_stats_loop(interval_seconds))\n    logger.info(\"Dashboard broadcast task started\")\n</code></pre>"},{"location":"api/v1/dashboard/#app.api.v1.endpoints.dashboard.stop_broadcast_task","title":"<code>stop_broadcast_task()</code>  <code>async</code>","text":"<p>Stop the periodic broadcast background task.</p> Source code in <code>app/api/v1/endpoints/dashboard.py</code> <pre><code>async def stop_broadcast_task() -&gt; None:\n    \"\"\"Stop the periodic broadcast background task.\"\"\"\n    global _broadcast_task, _broadcast_running\n\n    if _broadcast_task is None:\n        return\n\n    _broadcast_running = False\n\n    # Wait for task to finish (should exit quickly after flag set)\n    try:\n        await asyncio.wait_for(_broadcast_task, timeout=10.0)\n    except asyncio.TimeoutError:\n        logger.warning(\"Dashboard broadcast task did not stop gracefully, cancelling\")\n        _broadcast_task.cancel()\n\n    _broadcast_task = None\n    logger.info(\"Dashboard broadcast task stopped\")\n</code></pre>"},{"location":"api/v1/users/","title":"Users","text":""},{"location":"api/v1/users/#app.api.v1.endpoints.users.create_user","title":"<code>create_user(*, user_in, service, current_admin)</code>  <code>async</code>","text":"<p>Create new user. Admin only.</p> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.post(\"/\", response_model=UserRead)\nasync def create_user(\n    *,\n    user_in: UserCreate,\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n) -&gt; Any:\n    \"\"\"\n    Create new user. Admin only.\n    \"\"\"\n    return await service.create(user_in)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.delete_user","title":"<code>delete_user(*, user_id, service, current_admin)</code>  <code>async</code>","text":"<p>Delete a user. Admin only.</p> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.delete(\"/{user_id}\", response_model=UserRead)\nasync def delete_user(\n    *,\n    user_id: UUID,\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n) -&gt; Any:\n    \"\"\"\n    Delete a user. Admin only.\n    \"\"\"\n    return await service.delete(user_id)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.delete_user_avatar","title":"<code>delete_user_avatar(*, user_id, service, current_user)</code>  <code>async</code>","text":"<p>Remove the avatar image from a user.</p> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.delete(\"/{user_id}/avatar\", response_model=UserRead)\nasync def delete_user_avatar(\n    *,\n    user_id: UUID,\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -&gt; Any:\n    \"\"\"\n    Remove the avatar image from a user.\n    \"\"\"\n    if current_user.id != user_id and current_user.role != \"admin\":\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    return await service.remove_avatar(user_id)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.get_user_avatar","title":"<code>get_user_avatar(*, user_id, service)</code>  <code>async</code>","text":"<p>Get the avatar image file for a user.</p> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.get(\"/{user_id}/avatar\")\nasync def get_user_avatar(\n    *,\n    user_id: UUID,\n    service: Annotated[UserService, Depends(get_user_service)],\n) -&gt; Any:\n    \"\"\"\n    Get the avatar image file for a user.\n    \"\"\"\n    file_path = await service.get_avatar_path(user_id)\n    if not file_path:\n        raise HTTPException(status_code=404, detail=\"Avatar not found\")\n\n    return FileResponse(file_path)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.read_user_me","title":"<code>read_user_me(current_user)</code>  <code>async</code>","text":"<p>Get current user.</p> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.get(\"/me\", response_model=UserRead)\nasync def read_user_me(current_user: Annotated[User, Depends(get_current_user)]) -&gt; Any:\n    \"\"\"\n    Get current user.\n    \"\"\"\n    return current_user\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.read_users","title":"<code>read_users(service, current_admin, skip=0, limit=100)</code>  <code>async</code>","text":"<p>Retrieve users. Admin only.</p> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.get(\"/\", response_model=List[UserRead])\nasync def read_users(\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n    skip: int = 0,\n    limit: int = 100,\n) -&gt; Any:\n    \"\"\"\n    Retrieve users. Admin only.\n    \"\"\"\n    return await service.get_multi(skip=skip, limit=limit)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.update_user","title":"<code>update_user(*, user_id, user_in, service, current_admin)</code>  <code>async</code>","text":"<p>Update a user. Admin only.</p> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.patch(\"/{user_id}\", response_model=UserRead)\nasync def update_user(\n    *,\n    user_id: UUID,\n    user_in: UserUpdate,\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n) -&gt; Any:\n    \"\"\"\n    Update a user. Admin only.\n    \"\"\"\n    return await service.update(user_id, user_in)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.upload_user_avatar","title":"<code>upload_user_avatar(*, user_id, file=File(...), service, current_user)</code>  <code>async</code>","text":"<p>Upload an avatar image for a user.</p> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.post(\"/{user_id}/avatar\", response_model=UserRead)\nasync def upload_user_avatar(\n    *,\n    user_id: UUID,\n    file: UploadFile = File(...),\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -&gt; Any:\n    \"\"\"\n    Upload an avatar image for a user.\n    \"\"\"\n    if current_user.id != user_id and current_user.role != \"admin\":\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    return await service.upload_avatar(user_id, file)\n</code></pre>"},{"location":"api/v1/ws/","title":"WebSockets","text":"<p>WebSocket API endpoints for the Vectra backend.</p> <p>This module provides the WebSocket endpoint for both frontend clients and the Python worker, handling real-time communication and status updates.</p>"},{"location":"api/v1/ws/#app.api.v1.ws.ClientType","title":"<code>ClientType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enumeration for different types of WebSocket clients.</p> <p>Attributes:</p> <ul> <li> <code>CLIENT</code>           \u2013            <p>Represents a frontend client.</p> </li> <li> <code>WORKER</code>           \u2013            <p>Represents a backend worker.</p> </li> </ul> Source code in <code>app/api/v1/ws.py</code> <pre><code>class ClientType(StrEnum):\n    \"\"\"\n    Enumeration for different types of WebSocket clients.\n\n    Attributes:\n        CLIENT: Represents a frontend client.\n        WORKER: Represents a backend worker.\n    \"\"\"\n\n    CLIENT = \"client\"\n    WORKER = \"worker\"\n</code></pre>"},{"location":"api/v1/ws/#app.api.v1.ws.websocket_endpoint","title":"<code>websocket_endpoint(websocket, manager, client_type=Query(ClientType.CLIENT), token=Query(default=None))</code>  <code>async</code>","text":"<p>WebSocket Endpoint handling both Frontend clients and the Python Worker.</p> <p>This endpoint manages the lifecycle of WebSocket connections, including handshake, security checks, message processing, and disconnection. Workers must provide valid authentication using a secret token.</p> <p>Parameters:</p> <ul> <li> <code>websocket</code>               (<code>WebSocket</code>)           \u2013            <p>The WebSocket object for the current connection.</p> </li> <li> <code>manager</code>               (<code>Annotated[ConnectionManager, Depends(get_connection_manager)]</code>)           \u2013            <p>The ConnectionManager instance for handling connections.</p> </li> <li> <code>client_type</code>               (<code>ClientType</code>, default:                   <code>Query(CLIENT)</code> )           \u2013            <p>The type of client connecting (client or worker). Defaults to ClientType.CLIENT.</p> </li> <li> <code>token</code>               (<code>Optional[str]</code>, default:                   <code>Query(default=None)</code> )           \u2013            <p>An optional token for authentication, primarily for workers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>WebSocketDisconnect</code>             \u2013            <p>If the WebSocket connection is intentionally closed.</p> </li> <li> <code>Exception</code>             \u2013            <p>For any unexpected errors during connection or message processing.</p> </li> </ul> Source code in <code>app/api/v1/ws.py</code> <pre><code>@router.websocket(\"/ws\")\nasync def websocket_endpoint(\n    websocket: WebSocket,\n    manager: Annotated[ConnectionManager, Depends(get_connection_manager)],\n    client_type: ClientType = Query(ClientType.CLIENT),\n    token: Optional[str] = Query(default=None),\n) -&gt; None:\n    \"\"\"\n    WebSocket Endpoint handling both Frontend clients and the Python Worker.\n\n    This endpoint manages the lifecycle of WebSocket connections, including\n    handshake, security checks, message processing, and disconnection.\n    Workers must provide valid authentication using a secret token.\n\n    Args:\n        websocket: The WebSocket object for the current connection.\n        manager: The ConnectionManager instance for handling connections.\n        client_type: The type of client connecting (client or worker).\n            Defaults to ClientType.CLIENT.\n        token: An optional token for authentication, primarily for workers.\n\n    Returns:\n        None\n\n    Raises:\n        WebSocketDisconnect: If the WebSocket connection is intentionally closed.\n        Exception: For any unexpected errors during connection or message processing.\n    \"\"\"\n    func_name: str = \"websocket_endpoint\"\n\n    logger.debug(\"WebSocket endpoint hit\")\n\n    # 1. Connection Phase (Handshake)\n    try:\n        # Worker Security Check\n        if client_type == ClientType.WORKER:\n            # Extract secret from headers or query param\n            secret: Optional[str] = websocket.headers.get(\"x-worker-secret\")\n\n            # Also allow query param for flexibility if headers are hard in some clients\n            if not secret and token:\n                secret = token\n\n            # Securely compare secrets\n            if not secret or not secrets.compare_digest(secret, str(settings.WORKER_SECRET)):\n                logger.warning(\n                    f\"SECURITY | {func_name} | Unauthorized Worker Attempt. \"\n                    f\"Received: {secret!r} | Expected: [REDACTED]\"\n                )\n                # 1008 = Policy Violation\n                await websocket.close(code=status.WS_1008_POLICY_VIOLATION)\n                return\n\n        await manager.connect(websocket)\n\n        conn_id: str = str(getattr(websocket, \"conn_id\", \"?\"))\n        if client_type == ClientType.WORKER:\n            logger.info(f\"START | {func_name} | Secure Worker Connected [ID: {conn_id}]\")\n            await manager.register_worker(websocket)\n        else:\n            logger.debug(f\"START | {func_name} | Client Connected [ID: {conn_id}]\")\n\n    except Exception as e:\n        logger.error(f\"FAIL | {func_name} | Connection Refused | Error: {e}\", exc_info=True)\n        return\n\n    # 2. Main Loop\n    try:\n        while True:\n            # Keep the connection open and listen for messages\n            data: str = await websocket.receive_text()\n\n            # Heartbeat (Client-side initiated)\n            if data == \"ping\":\n                await websocket.send_text(\"pong\")\n                continue\n\n            # Diagnostics\n            if data == \"get_worker_status\":\n                await manager.emit_worker_status(manager.is_worker_online)\n                continue\n\n            # Worker Broadcast: If worker sends a message, re-broadcast it to frontends\n            if client_type == ClientType.WORKER:\n                try:\n                    # We assume worker sends valid JSON that matches the broadcast format\n                    message: Dict[str, Any] = json.loads(data)\n                    await manager.broadcast(message)\n                except json.JSONDecodeError as e:\n                    logger.warning(f\"Context | {func_name} | Msg: Invalid JSON from worker | Error: {e!r}\")\n                    # Intentionally continue to not break the worker connection on bad JSON\n                    continue\n                except Exception as e:\n                    logger.error(\n                        f\"FAIL | {func_name} | Worker broadcast error | Error: {e}\",\n                        exc_info=True,\n                    )\n                    # Intentionally continue to not break the worker connection on internal errors\n                    continue\n\n    except WebSocketDisconnect as e:\n        logger.info(f\"FINISH | {func_name} | Msg: {client_type} Disconnected (Code: {e.code!r})\")\n    except Exception as e:\n        logger.error(f\"FAIL | {func_name} | Msg: Unexpected Error: {e!r}\", exc_info=True)\n    finally:\n        # Ensure cleanup on any exit\n        try:\n            await manager.disconnect(websocket)\n        except Exception:\n            # Ignore failures during an already failing connection\n            pass\n</code></pre>"}]}