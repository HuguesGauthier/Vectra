{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83e\udde0 Vectra: The Intelligent Agentic RAG Assistant","text":"<p>Unlock the potential of your corporate data with a powerful and intuitive chat interface.</p> <p>Vectra is more than just a chatbot. It's a comprehensive artificial intelligence platform designed to unify your structured and unstructured data, providing precise, sourced, and actionable answers in real-time.</p>"},{"location":"#why-choose-vectra","title":"\u2728 Why Choose Vectra?","text":"<ul> <li>Hybrid Intelligence: Intelligently switches between vector search (RAG) for your documents and SQL query generation for your analytical data.</li> <li>Total Control: A self-hosted architecture that ensures your data remains private and under your control.</li> <li>Premium Experience: A modern interface with streaming responses, dynamic chart rendering, and precise source citations.</li> <li>LLM Agnostic: Compatible with the best models on the market (Gemini, OpenAI, Mistral, Ollama).</li> </ul>"},{"location":"#ready-to-transform-your-business","title":"\ud83d\ude80 Ready to Transform Your Business?","text":"<p>Explore our documentation to discover how to deploy Vectra and connect your knowledge bases.</p> <ul> <li>Quick Start: Launch your instance in minutes with Docker.</li> <li>Configuration: Connect your SQL databases, Qdrant, and configure your AI models.</li> <li>Architecture: Dive into the technical details of our tri-hybrid stack.</li> <li>API Reference: Integrate Vectra features into your own applications.</li> </ul> <p> Powered by FastAPI, Vue 3, and state-of-the-art artificial intelligence. </p>"},{"location":"architecture/","title":"Vectra Architecture","text":"<p>Vectra is an enterprise RAG (Retrieval-Augmented Generation) solution designed to transform unstructured data into actionable knowledge via an intelligent chat interface.</p>"},{"location":"architecture/#overview","title":"Overview","text":"<p>The architecture follows a distributed model consisting of a reactive API, an asynchronous worker for data ingestion, and a multi-provider AI stack.</p> <pre><code>graph TD\n    User([User]) &lt;--&gt; Frontend[Frontend Vue.js/Quasar]\n    Frontend &lt;--&gt; API[FastAPI Backend]\n\n    API &lt;--&gt; Postgres[(PostgreSQL)]\n    API &lt;--&gt; Redis[(Redis Cache)]\n    API &lt;--&gt; Qdrant[(Qdrant Vector DB)]\n\n    API -- WebSocket triggers --&gt; Worker[Background Worker]\n    Worker -- Ingestion --&gt; Postgres\n    Worker -- Vectorization --&gt; Qdrant\n\n    API -- LLM/Embed --&gt; AI[Gemini / OpenAI / Mistral]\n    Worker -- Embeddings --&gt; AI</code></pre>"},{"location":"architecture/#main-components","title":"Main Components","text":""},{"location":"architecture/#1-backend-api-fastapi","title":"1. Backend API (FastAPI)","text":"<p>The heart of the system, responsible for real-time orchestration:</p> <ul> <li>Session Management: Authentication and conversation history.</li> <li>RAG Orchestration: Integration with LlamaIndex for chunking, indexing, and retrieval.</li> <li>WebSocket Manager: Real-time broadcast of responses and synchronization states.</li> <li>Semantic Cache: Uses Redis to store results for similar queries to reduce latency and costs.</li> </ul>"},{"location":"architecture/#2-background-worker","title":"2. Background Worker","text":"<p>An autonomous service dedicated to heavy tasks:</p> <ul> <li>Multi-Source Ingestion: Scanning and extracting data from various sources (Connectors).</li> <li>Vectorization Pipeline: Transforming documents into vectors via embedding models (Gemini 004).</li> <li>Real-Time Synchronization: Connected to the API via WebSocket to react instantly to user requests.</li> </ul>"},{"location":"architecture/#3-persistence-layer","title":"3. Persistence Layer","text":"<ul> <li>PostgreSQL: Stores metadata, connector configurations, and document structure.</li> <li>Qdrant: High-performance vector database for ultra-fast semantic search.</li> <li>Redis: Semantic cache and temporary storage.</li> </ul>"},{"location":"architecture/#4-artificial-intelligence","title":"4. Artificial Intelligence","text":"<p>Vectra is \"Model Agnostic\" but optimized for the Google Cloud suite:</p> <ul> <li>Chat Models: Gemini 1.5 Pro/Flash for complex reasoning.</li> <li>Embeddings: Gemini Text Embedding 004 for state-of-the-art semantic representation.</li> <li>Reranking: Uses reranking models to refine result relevance.</li> </ul>"},{"location":"architecture/#data-flow-rag","title":"Data Flow (RAG)","text":"<ol> <li>Request: The user asks a question via the frontend.</li> <li>Cache: The API checks Redis to see if a similar question has already been processed.</li> <li>Retrieval: If not, Vectra queries Qdrant to extract the most relevant passages.</li> <li>Augmentation: The extracted context is injected into the LLM prompt.</li> <li>Generation: The LLM generates a sourced and accurate response.</li> <li>Streaming: The response is sent back in chunks via WebSocket for a smooth user experience.</li> </ol>"},{"location":"config/","title":"Configuration","text":"<p>Vectra uses environment variables for configuration. Copy the <code>.env.example</code> file to <code>.env</code> and fill it in.</p> <pre><code>GEMINI_API_KEY=your_key_here\nDATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/vectra\nQDRANT_HOST=localhost\nREDIS_HOST=localhost\n</code></pre> <p>For a full list of available settings, please refer to the <code>app/core/settings.py</code> file.</p>"},{"location":"install/","title":"Installation","text":"<p>Vectra can be deployed quickly via Docker (recommended) or manually for development.</p>"},{"location":"install/#quick-start-docker","title":"\ud83d\ude80 Quick Start (Docker)","text":"<p>The easiest way to launch Vectra in production or for a quick test.</p> <ol> <li>Clone the project:</li> </ol> <pre><code>git clone https://github.com/HuguesGauthier/Vectra.git\ncd Vectra\n</code></pre> <ol> <li>Configure environment:</li> </ol> <pre><code>cp .env.example .env\n# Edit the .env file with your API keys (Gemini, etc.)\n</code></pre> <ol> <li>Launch services:    <pre><code>docker-compose up -d\n</code></pre></li> </ol> <p>Access the UI at: http://localhost:9000</p>"},{"location":"install/#manual-installation-development","title":"\ud83d\udee0\ufe0f Manual Installation (Development)","text":"<p>If you wish to modify the code or contribute to the project.</p>"},{"location":"install/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>Node.js (for the frontend)</li> <li>Databases: PostgreSQL, Qdrant, and Redis must be accessible.</li> </ul>"},{"location":"install/#backend","title":"Backend","text":"<ol> <li>Navigate to the backend folder:    <pre><code>cd backend\n</code></pre></li> <li>Create a virtual environment:    <pre><code>python -m venv .venv\n.venv\\Scripts\\activate  # Windows\n</code></pre></li> <li>Install dependencies:    <pre><code>pip install -r requirements.txt\n</code></pre></li> <li>Launch the API:    <pre><code>python main.py\n</code></pre></li> </ol>"},{"location":"install/#frontend","title":"Frontend","text":"<ol> <li>Navigate to the frontend folder:    <pre><code>cd frontend\n</code></pre></li> <li>Install dependencies:    <pre><code>npm install\n</code></pre></li> <li>Launch the development server:    <pre><code>npm run dev\n</code></pre></li> </ol>"},{"location":"api/v1/analytics/","title":"Analytics","text":"<p>Advanced Analytics API Endpoints.</p>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.broadcast_analytics_loop","title":"<code>broadcast_analytics_loop(interval_seconds=10)</code>  <code>async</code>","text":"<p>Background task that periodically broadcasts advanced analytics stats via WebSocket.</p> <p>Parameters:</p> <ul> <li> <code>interval_seconds</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Broadcast interval in seconds (default: 10). Higher than dashboard stats due to query complexity.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>async def broadcast_analytics_loop(interval_seconds: int = 10) -&gt; None:\n    \"\"\"\n    Background task that periodically broadcasts advanced analytics stats via WebSocket.\n\n    Args:\n        interval_seconds: Broadcast interval in seconds (default: 10).\n            Higher than dashboard stats due to query complexity.\n    \"\"\"\n    global _broadcast_running\n    _broadcast_running = True\n\n    logger.info(\"Starting advanced analytics broadcast loop (interval: %ds)\", interval_seconds)\n\n    from app.core.connection_manager import manager\n\n    while _broadcast_running:\n        try:\n            # P0 Fix: Pass the factory, not a session, to support parallel execution inside loop\n            factory = get_session_factory()\n            # Initialize SettingsService (no DB session needed for advanced analytics as they use defaults/env)\n            settings_service = SettingsService(db=None)\n            service = AnalyticsService(session_factory=factory, settings_service=settings_service)\n\n            # Use standard defaults for the live view\n            stats = await service.get_all_advanced_analytics(\n                ttft_hours=24, step_days=7, cache_hours=24, cost_hours=24, trending_limit=10\n            )\n\n            # Broadcast via WebSocket\n            await manager.emit_advanced_analytics_stats(stats.model_dump(mode=\"json\"))\n\n        except Exception as e:\n            logger.error(\"Error in analytics broadcast: %s\", e, exc_info=True)\n\n        # Wait for next interval\n        await asyncio.sleep(interval_seconds)\n\n    logger.info(\"Advanced analytics broadcast loop stopped\")\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_advanced_analytics","title":"<code>get_advanced_analytics(service, assistant_id=Query(None, description='Filter by assistant ID'), ttft_hours=Query(24, ge=1, le=168, description='TTFT analysis period in hours'), step_days=Query(7, ge=1, le=90, description='Step breakdown period in days'), cache_hours=Query(24, ge=1, le=168, description='Cache metrics period in hours'), cost_hours=Query(24, ge=1, le=168, description='Cost analysis period in hours'), trending_limit=Query(10, ge=1, le=50, description='Number of trending topics'))</code>  <code>async</code>","text":"<p>Get comprehensive advanced analytics for the admin dashboard.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[AnalyticsService, Depends(get_analytics_service)]</code>)           \u2013            <p>The analytics service instance.</p> </li> <li> <code>assistant_id</code>               (<code>Optional[UUID]</code>, default:                   <code>Query(None, description='Filter by assistant ID')</code> )           \u2013            <p>Optional filter by assistant ID.</p> </li> <li> <code>ttft_hours</code>               (<code>int</code>, default:                   <code>Query(24, ge=1, le=168, description='TTFT analysis period in hours')</code> )           \u2013            <p>TTFT analysis period in hours.</p> </li> <li> <code>step_days</code>               (<code>int</code>, default:                   <code>Query(7, ge=1, le=90, description='Step breakdown period in days')</code> )           \u2013            <p>Step breakdown period in days.</p> </li> <li> <code>cache_hours</code>               (<code>int</code>, default:                   <code>Query(24, ge=1, le=168, description='Cache metrics period in hours')</code> )           \u2013            <p>Cache metrics period in hours.</p> </li> <li> <code>cost_hours</code>               (<code>int</code>, default:                   <code>Query(24, ge=1, le=168, description='Cost analysis period in hours')</code> )           \u2013            <p>Cost analysis period in hours.</p> </li> <li> <code>trending_limit</code>               (<code>int</code>, default:                   <code>Query(10, ge=1, le=50, description='Number of trending topics')</code> )           \u2013            <p>Number of trending topics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AdvancedAnalyticsResponse</code> (              <code>AdvancedAnalyticsResponse</code> )          \u2013            <p>A comprehensive analytics response including TTFT percentiles, pipeline step breakdown, cache hit rate, trending topics, topic diversity score, assistant token costs, and document freshness.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/advanced\", response_model=AdvancedAnalyticsResponse)\nasync def get_advanced_analytics(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n    assistant_id: Optional[UUID] = Query(None, description=\"Filter by assistant ID\"),\n    ttft_hours: int = Query(24, ge=1, le=168, description=\"TTFT analysis period in hours\"),\n    step_days: int = Query(7, ge=1, le=90, description=\"Step breakdown period in days\"),\n    cache_hours: int = Query(24, ge=1, le=168, description=\"Cache metrics period in hours\"),\n    cost_hours: int = Query(24, ge=1, le=168, description=\"Cost analysis period in hours\"),\n    trending_limit: int = Query(10, ge=1, le=50, description=\"Number of trending topics\"),\n) -&gt; AdvancedAnalyticsResponse:\n    \"\"\"\n    Get comprehensive advanced analytics for the admin dashboard.\n\n    Args:\n        service: The analytics service instance.\n        assistant_id: Optional filter by assistant ID.\n        ttft_hours: TTFT analysis period in hours.\n        step_days: Step breakdown period in days.\n        cache_hours: Cache metrics period in hours.\n        cost_hours: Cost analysis period in hours.\n        trending_limit: Number of trending topics.\n\n    Returns:\n        AdvancedAnalyticsResponse: A comprehensive analytics response including\n            TTFT percentiles, pipeline step breakdown, cache hit rate, trending topics,\n            topic diversity score, assistant token costs, and document freshness.\n    \"\"\"\n    return await service.get_all_advanced_analytics(\n        ttft_hours=ttft_hours,\n        step_days=step_days,\n        cache_hours=cache_hours,\n        cost_hours=cost_hours,\n        trending_limit=trending_limit,\n        assistant_id=assistant_id,\n    )\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_assistant_costs","title":"<code>get_assistant_costs(service, hours=Query(24, ge=1, le=168, description='Analysis period in hours'))</code>  <code>async</code>","text":"<p>Get token costs by assistant.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[AnalyticsService, Depends(get_analytics_service)]</code>)           \u2013            <p>The analytics service instance.</p> </li> <li> <code>hours</code>               (<code>int</code>, default:                   <code>Query(24, ge=1, le=168, description='Analysis period in hours')</code> )           \u2013            <p>Analysis period in hours.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[AssistantCost]</code>           \u2013            <p>list[AssistantCost]: A list of costs per assistant.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/costs\", response_model=list[AssistantCost])\nasync def get_assistant_costs(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n    hours: int = Query(24, ge=1, le=168, description=\"Analysis period in hours\"),\n) -&gt; list[AssistantCost]:\n    \"\"\"\n    Get token costs by assistant.\n\n    Args:\n        service: The analytics service instance.\n        hours: Analysis period in hours.\n\n    Returns:\n        list[AssistantCost]: A list of costs per assistant.\n    \"\"\"\n    return await service.get_assistant_costs(hours)\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_document_freshness","title":"<code>get_document_freshness(service)</code>  <code>async</code>","text":"<p>Get knowledge base document freshness distribution.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[AnalyticsService, Depends(get_analytics_service)]</code>)           \u2013            <p>The analytics service instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DocumentFreshness]</code>           \u2013            <p>list[DocumentFreshness]: A list representing document freshness distribution.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/freshness\", response_model=list[DocumentFreshness])\nasync def get_document_freshness(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n) -&gt; list[DocumentFreshness]:\n    \"\"\"\n    Get knowledge base document freshness distribution.\n\n    Args:\n        service: The analytics service instance.\n\n    Returns:\n        list[DocumentFreshness]: A list representing document freshness distribution.\n    \"\"\"\n    return await service.get_document_freshness()\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_trending_topics","title":"<code>get_trending_topics(service, assistant_id=Query(None, description='Filter by assistant ID'), limit=Query(10, ge=1, le=50, description='Number of topics to return'))</code>  <code>async</code>","text":"<p>Get top trending questions/topics.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[AnalyticsService, Depends(get_analytics_service)]</code>)           \u2013            <p>The analytics service instance.</p> </li> <li> <code>assistant_id</code>               (<code>Optional[UUID]</code>, default:                   <code>Query(None, description='Filter by assistant ID')</code> )           \u2013            <p>Optional filter by assistant ID.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>Query(10, ge=1, le=50, description='Number of topics to return')</code> )           \u2013            <p>Number of topics to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[TrendingTopic]</code>           \u2013            <p>list[TrendingTopic]: A list of trending topics.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/trending\", response_model=list[TrendingTopic])\nasync def get_trending_topics(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n    assistant_id: Optional[UUID] = Query(None, description=\"Filter by assistant ID\"),\n    limit: int = Query(10, ge=1, le=50, description=\"Number of topics to return\"),\n) -&gt; list[TrendingTopic]:\n    \"\"\"\n    Get top trending questions/topics.\n\n    Args:\n        service: The analytics service instance.\n        assistant_id: Optional filter by assistant ID.\n        limit: Number of topics to return.\n\n    Returns:\n        list[TrendingTopic]: A list of trending topics.\n    \"\"\"\n    return await service.get_trending_topics(assistant_id, limit)\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_ttft_percentiles","title":"<code>get_ttft_percentiles(service, hours=Query(24, ge=1, le=168, description='Analysis period in hours'))</code>  <code>async</code>","text":"<p>Get Time-to-First-Token percentiles.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[AnalyticsService, Depends(get_analytics_service)]</code>)           \u2013            <p>The analytics service instance.</p> </li> <li> <code>hours</code>               (<code>int</code>, default:                   <code>Query(24, ge=1, le=168, description='Analysis period in hours')</code> )           \u2013            <p>Analysis period in hours.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TTFTPercentiles</code> (              <code>TTFTPercentiles</code> )          \u2013            <p>The calculated TTFT percentiles (p50, p95, p99).</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/ttft\", response_model=TTFTPercentiles)\nasync def get_ttft_percentiles(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n    hours: int = Query(24, ge=1, le=168, description=\"Analysis period in hours\"),\n) -&gt; TTFTPercentiles:\n    \"\"\"\n    Get Time-to-First-Token percentiles.\n\n    Args:\n        service: The analytics service instance.\n        hours: Analysis period in hours.\n\n    Returns:\n        TTFTPercentiles: The calculated TTFT percentiles (p50, p95, p99).\n    \"\"\"\n    result = await service.get_ttft_percentiles(hours)\n\n    if not result:\n        return TTFTPercentiles(p50=0.0, p95=0.0, p99=0.0, period_hours=hours)\n\n    return result\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.start_broadcast_task","title":"<code>start_broadcast_task(interval_seconds=10)</code>  <code>async</code>","text":"<p>Start the periodic broadcast background task.</p> <p>Parameters:</p> <ul> <li> <code>interval_seconds</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Broadcast interval in seconds.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>async def start_broadcast_task(interval_seconds: int = 10) -&gt; None:\n    \"\"\"\n    Start the periodic broadcast background task.\n\n    Args:\n        interval_seconds: Broadcast interval in seconds.\n    \"\"\"\n    global _broadcast_task, _broadcast_running\n\n    if _broadcast_task is not None and not _broadcast_task.done():\n        logger.warning(\"Analytics broadcast task already running\")\n        return\n\n    _broadcast_running = True\n    _broadcast_task = asyncio.create_task(broadcast_analytics_loop(interval_seconds))\n    logger.info(\"Analytics broadcast task started\")\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.stop_broadcast_task","title":"<code>stop_broadcast_task()</code>  <code>async</code>","text":"<p>Stop the periodic broadcast background task.</p> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>async def stop_broadcast_task() -&gt; None:\n    \"\"\"\n    Stop the periodic broadcast background task.\n    \"\"\"\n    global _broadcast_task, _broadcast_running\n\n    if _broadcast_task is None:\n        return\n\n    _broadcast_running = False\n\n    # Wait for task to finish\n    try:\n        await asyncio.wait_for(_broadcast_task, timeout=10.0)\n    except asyncio.TimeoutError:\n        logger.warning(\"Analytics broadcast task did not stop gracefully, cancelling\")\n        _broadcast_task.cancel()\n    except Exception as e:\n        logger.error(\"Error during stop_broadcast_task: %s\", e)\n\n    _broadcast_task = None\n    logger.info(\"Analytics broadcast task stopped\")\n</code></pre>"},{"location":"api/v1/assistants/","title":"Assistants","text":""},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.clear_assistant_cache","title":"<code>clear_assistant_cache(assistant_id, service, current_user)</code>  <code>async</code>","text":"<p>Manually purge the semantic cache for a specific assistant.</p> <p>Useful when documents are updated or LLM instructions change.</p> <p>Parameters:</p> <ul> <li> <code>assistant_id</code>               (<code>UUID</code>)           \u2013            <p>Unique identifier of the assistant.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>Assistant service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>Current authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, int]</code>           \u2013            <p>A dictionary containing the number of deleted cache entries.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TechnicalError</code>             \u2013            <p>If clearing the cache fails.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.delete(\"/{assistant_id}/cache\", response_model=Dict[str, int])\nasync def clear_assistant_cache(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; Dict[str, int]:\n    \"\"\"\n    Manually purge the semantic cache for a specific assistant.\n\n    Useful when documents are updated or LLM instructions change.\n\n    Args:\n        assistant_id: Unique identifier of the assistant.\n        service: Assistant service instance.\n        current_user: Current authenticated admin user.\n\n    Returns:\n        A dictionary containing the number of deleted cache entries.\n\n    Raises:\n        TechnicalError: If clearing the cache fails.\n    \"\"\"\n    try:\n        count = await service.clear_cache(assistant_id)\n        return {\"deleted_count\": count}\n    except Exception as e:\n        logger.error(f\"Failed to clear cache for assistant {assistant_id}: {e}\", exc_info=True)\n        if isinstance(e, (FunctionalError, TechnicalError)):\n            raise\n        raise TechnicalError(f\"Failed to clear cache: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.create_assistant","title":"<code>create_assistant(assistant, service, current_user)</code>  <code>async</code>","text":"<p>Create a new assistant (Admin only).</p> <p>Parameters:</p> <ul> <li> <code>assistant</code>               (<code>AssistantCreate</code>)           \u2013            <p>Assistant creation data.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>Assistant service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>Current authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AssistantResponse</code>           \u2013            <p>The created assistant response object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FunctionalError</code>             \u2013            <p>If there is a validation or functional error.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If creating the assistant fails.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.post(\"/\", response_model=AssistantResponse, status_code=status.HTTP_201_CREATED)\nasync def create_assistant(\n    assistant: AssistantCreate,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; AssistantResponse:\n    \"\"\"\n    Create a new assistant (Admin only).\n\n    Args:\n        assistant: Assistant creation data.\n        service: Assistant service instance.\n        current_user: Current authenticated admin user.\n\n    Returns:\n        The created assistant response object.\n\n    Raises:\n        FunctionalError: If there is a validation or functional error.\n        TechnicalError: If creating the assistant fails.\n    \"\"\"\n    try:\n        return await service.create_assistant(assistant)\n    except Exception as e:\n        logger.error(f\"Failed to create assistant: {e}\", exc_info=True)\n        if isinstance(e, (FunctionalError, TechnicalError)):\n            raise\n        raise TechnicalError(f\"Failed to create assistant: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.delete_assistant","title":"<code>delete_assistant(assistant_id, service, current_user)</code>  <code>async</code>","text":"<p>Delete an assistant (Admin only).</p> <p>Parameters:</p> <ul> <li> <code>assistant_id</code>               (<code>UUID</code>)           \u2013            <p>Unique identifier of the assistant to delete.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>Assistant service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>Current authenticated admin user.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EntityNotFound</code>             \u2013            <p>If the assistant does not exist.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If deleting the assistant fails.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.delete(\"/{assistant_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_assistant(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; None:\n    \"\"\"\n    Delete an assistant (Admin only).\n\n    Args:\n        assistant_id: Unique identifier of the assistant to delete.\n        service: Assistant service instance.\n        current_user: Current authenticated admin user.\n\n    Raises:\n        EntityNotFound: If the assistant does not exist.\n        TechnicalError: If deleting the assistant fails.\n    \"\"\"\n    try:\n        success = await service.delete_assistant(assistant_id)\n        if not success:\n            raise EntityNotFound(\"Assistant not found\")\n        return  # 204 No Content\n    except EntityNotFound:\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to delete assistant {assistant_id}: {e}\", exc_info=True)\n        raise TechnicalError(f\"Failed to delete assistant: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.delete_assistant_avatar","title":"<code>delete_assistant_avatar(assistant_id, service, current_user)</code>  <code>async</code>","text":"<p>Remove the avatar image from the assistant.</p> <p>Parameters:</p> <ul> <li> <code>assistant_id</code>               (<code>UUID</code>)           \u2013            <p>Unique identifier of the assistant.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>Assistant service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>Current authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AssistantResponse</code>           \u2013            <p>The updated assistant response object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TechnicalError</code>             \u2013            <p>If removing the avatar fails.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.delete(\"/{assistant_id}/avatar\", response_model=AssistantResponse)\nasync def delete_assistant_avatar(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; AssistantResponse:\n    \"\"\"\n    Remove the avatar image from the assistant.\n\n    Args:\n        assistant_id: Unique identifier of the assistant.\n        service: Assistant service instance.\n        current_user: Current authenticated admin user.\n\n    Returns:\n        The updated assistant response object.\n\n    Raises:\n        TechnicalError: If removing the avatar fails.\n    \"\"\"\n    try:\n        return await service.remove_avatar(assistant_id)\n    except Exception as e:\n        logger.error(f\"Failed to remove avatar: {e}\", exc_info=True)\n        if isinstance(e, (FunctionalError, TechnicalError)):\n            raise\n        raise TechnicalError(f\"Failed to remove avatar: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.get_assistant","title":"<code>get_assistant(assistant_id, service, user)</code>  <code>async</code>","text":"<p>Get a single assistant by ID.</p> <p>Parameters:</p> <ul> <li> <code>assistant_id</code>               (<code>UUID</code>)           \u2013            <p>Unique identifier of the assistant.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>Assistant service instance.</p> </li> <li> <code>user</code>               (<code>Annotated[Optional[User], Depends(get_current_user_optional)]</code>)           \u2013            <p>Current optional user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AssistantResponse</code>           \u2013            <p>The assistant response object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EntityNotFound</code>             \u2013            <p>If the assistant does not exist.</p> </li> <li> <code>HTTPException</code>             \u2013            <p>If authentication is required but user is not logged in.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If fetching the assistant fails.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.get(\"/{assistant_id}\", response_model=AssistantResponse)\nasync def get_assistant(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    user: Annotated[Optional[User], Depends(get_current_user_optional)],\n) -&gt; AssistantResponse:\n    \"\"\"\n    Get a single assistant by ID.\n\n    Args:\n        assistant_id: Unique identifier of the assistant.\n        service: Assistant service instance.\n        user: Current optional user.\n\n    Returns:\n        The assistant response object.\n\n    Raises:\n        EntityNotFound: If the assistant does not exist.\n        HTTPException: If authentication is required but user is not logged in.\n        TechnicalError: If fetching the assistant fails.\n    \"\"\"\n    try:\n        assistant = await service.get_assistant(assistant_id)\n        if not assistant:\n            raise EntityNotFound(\"Assistant not found\")\n\n        # Access Control: If assistant requires authentication, user must be logged in.\n        if assistant.user_authentication and not user:\n            logger.warning(f\"Access denied for assistant {assistant_id}: User Authentication Required\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Authentication required for this assistant\",\n            )\n\n        return assistant\n\n    except (EntityNotFound, HTTPException):\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to fetch assistant {assistant_id}: {e}\", exc_info=True)\n        raise TechnicalError(f\"Failed to fetch assistant: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.get_assistant_avatar","title":"<code>get_assistant_avatar(assistant_id, service, user)</code>  <code>async</code>","text":"<p>Get the avatar image file.</p> <p>Parameters:</p> <ul> <li> <code>assistant_id</code>               (<code>UUID</code>)           \u2013            <p>Unique identifier of the assistant.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>Assistant service instance.</p> </li> <li> <code>user</code>               (<code>Annotated[Optional[User], Depends(get_current_user_optional)]</code>)           \u2013            <p>Current optional user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FileResponse</code>           \u2013            <p>The avatar image file response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>If the avatar or assistant is not found (404).</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If fetching the avatar fails.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.get(\"/{assistant_id}/avatar\")\nasync def get_assistant_avatar(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    user: Annotated[Optional[User], Depends(get_current_user_optional)],\n) -&gt; FileResponse:\n    \"\"\"\n    Get the avatar image file.\n\n    Args:\n        assistant_id: Unique identifier of the assistant.\n        service: Assistant service instance.\n        user: Current optional user.\n\n    Returns:\n        The avatar image file response.\n\n    Raises:\n        HTTPException: If the avatar or assistant is not found (404).\n        TechnicalError: If fetching the avatar fails.\n    \"\"\"\n    try:\n        # P0: Check Access Control before serving file\n        # Retrieve assistant first (lightweight DB fetch)\n        assistant = await service.get_assistant(assistant_id)\n        if not assistant:\n            raise EntityNotFound(\"Avatar not found\")  # Or Assistant not found\n\n        if assistant.user_authentication and not user:\n            # Private assistant -&gt; Private avatar\n            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Avatar not found\")  # Obfuscate existence\n\n        file_path = await service.get_avatar_path(assistant_id)\n        if not file_path:\n            raise EntityNotFound(\"Avatar not found\")\n\n        return FileResponse(file_path)\n    except EntityNotFound:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Avatar not found\")\n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to get avatar: {e}\", exc_info=True)\n        raise TechnicalError(f\"Failed to get avatar: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.get_assistants","title":"<code>get_assistants(service, user, skip=Query(0, ge=0), limit=Query(100, ge=1, le=1000))</code>  <code>async</code>","text":"<p>List all assistants.</p> <p>Public access allowed but filtered for guests. Private assistants are excluded if no user is authenticated.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>Assistant service instance.</p> </li> <li> <code>user</code>               (<code>Annotated[Optional[User], Depends(get_current_user_optional)]</code>)           \u2013            <p>Current optional user.</p> </li> <li> <code>skip</code>               (<code>int</code>, default:                   <code>Query(0, ge=0)</code> )           \u2013            <p>Number of records to skip for pagination.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>Query(100, ge=1, le=1000)</code> )           \u2013            <p>Maximum number of records to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[AssistantResponse]</code>           \u2013            <p>A list of assistant response objects.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TechnicalError</code>             \u2013            <p>If fetching assistants fails.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.get(\"/\", response_model=List[AssistantResponse])\nasync def get_assistants(\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    user: Annotated[Optional[User], Depends(get_current_user_optional)],\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n) -&gt; List[AssistantResponse]:\n    \"\"\"\n    List all assistants.\n\n    Public access allowed but filtered for guests. Private assistants are excluded\n    if no user is authenticated.\n\n    Args:\n        service: Assistant service instance.\n        user: Current optional user.\n        skip: Number of records to skip for pagination.\n        limit: Maximum number of records to return.\n\n    Returns:\n        A list of assistant response objects.\n\n    Raises:\n        TechnicalError: If fetching assistants fails.\n    \"\"\"\n    # Filter: If User is missing (Guest), exclude private assistants.\n    exclude_private = user is None\n\n    try:\n        # TODO: Refactor Service to support DB-side pagination (P1)\n        # Passing exclude_private to service layer\n        assistants = await service.get_assistants(exclude_private=exclude_private)\n\n        # Manual Slicing (Temporary P2 solution)\n        return assistants[skip : skip + limit]\n\n    except Exception as e:\n        logger.error(f\"Failed to fetch assistants: {e}\", exc_info=True)\n        raise TechnicalError(f\"Failed to fetch assistants: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.update_assistant","title":"<code>update_assistant(assistant_id, assistant, service, current_user)</code>  <code>async</code>","text":"<p>Update an existing assistant (Admin only).</p> <p>Parameters:</p> <ul> <li> <code>assistant_id</code>               (<code>UUID</code>)           \u2013            <p>Unique identifier of the assistant to update.</p> </li> <li> <code>assistant</code>               (<code>AssistantUpdate</code>)           \u2013            <p>Assistant update data.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>Assistant service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>Current authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AssistantResponse</code>           \u2013            <p>The updated assistant response object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EntityNotFound</code>             \u2013            <p>If the assistant does not exist.</p> </li> <li> <code>FunctionalError</code>             \u2013            <p>If there is a validation or functional error.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If updating the assistant fails.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.put(\"/{assistant_id}\", response_model=AssistantResponse)\nasync def update_assistant(\n    assistant_id: UUID,\n    assistant: AssistantUpdate,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; AssistantResponse:\n    \"\"\"\n    Update an existing assistant (Admin only).\n\n    Args:\n        assistant_id: Unique identifier of the assistant to update.\n        assistant: Assistant update data.\n        service: Assistant service instance.\n        current_user: Current authenticated admin user.\n\n    Returns:\n        The updated assistant response object.\n\n    Raises:\n        EntityNotFound: If the assistant does not exist.\n        FunctionalError: If there is a validation or functional error.\n        TechnicalError: If updating the assistant fails.\n    \"\"\"\n    try:\n        updated_assistant = await service.update_assistant(assistant_id, assistant)\n        if not updated_assistant:\n            raise EntityNotFound(\"Assistant not found\")\n        return updated_assistant\n    except (EntityNotFound, FunctionalError, TechnicalError):\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to update assistant {assistant_id}: {e}\", exc_info=True)\n        raise TechnicalError(f\"Failed to update assistant: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.upload_assistant_avatar","title":"<code>upload_assistant_avatar(assistant_id, file=File(...), service=None, current_user=None)</code>  <code>async</code>","text":"<p>Upload an avatar image for the assistant.</p> <p>Parameters:</p> <ul> <li> <code>assistant_id</code>               (<code>UUID</code>)           \u2013            <p>Unique identifier of the assistant.</p> </li> <li> <code>file</code>               (<code>UploadFile</code>, default:                   <code>File(...)</code> )           \u2013            <p>The image file to upload.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>, default:                   <code>None</code> )           \u2013            <p>Assistant service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>, default:                   <code>None</code> )           \u2013            <p>Current authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AssistantResponse</code>           \u2013            <p>The updated assistant response object with new avatar.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FunctionalError</code>             \u2013            <p>If the file is invalid or not an image.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If uploading the avatar fails.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.post(\"/{assistant_id}/avatar\", response_model=AssistantResponse)\nasync def upload_assistant_avatar(\n    assistant_id: UUID,\n    file: UploadFile = File(...),\n    service: Annotated[AssistantService, Depends(get_assistant_service)] = None,\n    current_user: Annotated[User, Depends(get_current_admin)] = None,\n) -&gt; AssistantResponse:\n    \"\"\"\n    Upload an avatar image for the assistant.\n\n    Args:\n        assistant_id: Unique identifier of the assistant.\n        file: The image file to upload.\n        service: Assistant service instance.\n        current_user: Current authenticated admin user.\n\n    Returns:\n        The updated assistant response object with new avatar.\n\n    Raises:\n        FunctionalError: If the file is invalid or not an image.\n        TechnicalError: If uploading the avatar fails.\n    \"\"\"\n    try:\n        # P0: Security Check - Ensure assistant exists implicitly via Service,\n        # but explicit check helps return 404 cleanly before processing file.\n        # Service handles this update logic internally via DB constraint or check.\n        return await service.upload_avatar(assistant_id, file)\n    except Exception as e:\n        logger.error(f\"Failed to upload avatar: {e}\", exc_info=True)\n        if isinstance(e, (FunctionalError, TechnicalError)):\n            raise\n        raise TechnicalError(f\"Failed to upload avatar: {e}\")\n</code></pre>"},{"location":"api/v1/chat/","title":"Chat","text":""},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.chat_stream","title":"<code>chat_stream(request, chat_service, assistant_service, user)</code>  <code>async</code>","text":"<p>Stream chat response for a session.</p> <p>Supports SSE (Server-Sent Events) via NDJSON or text/event-stream.</p> <p>Parameters:</p> <ul> <li> <code>request</code>               (<code>ChatRequest</code>)           \u2013            <p>The chat request payload.</p> </li> <li> <code>chat_service</code>               (<code>Annotated[ChatService, Depends(get_chat_service)]</code>)           \u2013            <p>The chat service instance.</p> </li> <li> <code>assistant_service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>The assistant service instance.</p> </li> <li> <code>user</code>               (<code>Annotated[Optional[User], Depends(get_optional_user)]</code>)           \u2013            <p>The optional authenticated user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>StreamingResponse</code>           \u2013            <p>A StreamingResponse yielding the chat stream.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EntityNotFound</code>             \u2013            <p>If the assistant is not found.</p> </li> <li> <code>HTTPException</code>             \u2013            <p>If authentication is required but user is not authenticated.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If an unexpected error occurs during initialization.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.post(\"/stream\")\nasync def chat_stream(\n    request: ChatRequest,\n    chat_service: Annotated[ChatService, Depends(get_chat_service)],\n    assistant_service: Annotated[AssistantService, Depends(get_assistant_service)],\n    user: Annotated[Optional[User], Depends(get_optional_user)],\n) -&gt; StreamingResponse:\n    \"\"\"\n    Stream chat response for a session.\n\n    Supports SSE (Server-Sent Events) via NDJSON or text/event-stream.\n\n    Args:\n        request: The chat request payload.\n        chat_service: The chat service instance.\n        assistant_service: The assistant service instance.\n        user: The optional authenticated user.\n\n    Returns:\n        A StreamingResponse yielding the chat stream.\n\n    Raises:\n        EntityNotFound: If the assistant is not found.\n        HTTPException: If authentication is required but user is not authenticated.\n        TechnicalError: If an unexpected error occurs during initialization.\n    \"\"\"\n    try:\n        # 1. Fetch Assistant (raw SQLAlchemy model for ChatService)\n        assistant_uuid = request.assistant_id\n        assistant = await assistant_service.get_assistant_model(assistant_uuid)\n        if not assistant:\n            raise EntityNotFound(\"Assistant not found\")\n\n        # 2. Authorization Check\n        user_id = str(user.id) if user else None\n        if assistant.user_authentication and not user_id:\n            logger.warning(f\"Access denied for assistant {assistant.id}: User Authentication Required\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Authentication required for this assistant\",\n            )\n\n        # 3. Stream\n        logger.info(f\"Init Chat Stream | Session: {request.session_id} | User: {user_id}\")\n\n        # Standard RAG Stream (with Vanna routing via SQL connector type)\n        return StreamingResponse(\n            chat_service.stream_chat(\n                request.message,\n                assistant,\n                request.session_id,\n                language=request.language,\n                history=request.history,\n                user_id=user_id,\n            ),\n            media_type=\"application/x-ndjson\",\n        )\n\n    except (FunctionalError, EntityNotFound, HTTPException):\n        raise\n    except Exception as e:\n        logger.error(f\"Chat stream initialization failed: {e}\", exc_info=True)\n        raise TechnicalError(f\"Chat stream initialization failed: {e}\")\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.debug_stream","title":"<code>debug_stream(request, chat_service, assistant_service, user)</code>  <code>async</code>","text":"<p>Debug version that returns full exceptions.</p> <p>Parameters:</p> <ul> <li> <code>request</code>               (<code>ChatRequest</code>)           \u2013            <p>The chat request payload.</p> </li> <li> <code>chat_service</code>               (<code>Annotated[ChatService, Depends(get_chat_service)]</code>)           \u2013            <p>The chat service instance.</p> </li> <li> <code>assistant_service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>The assistant service instance.</p> </li> <li> <code>user</code>               (<code>Annotated[Optional[User], Depends(get_optional_user)]</code>)           \u2013            <p>The optional authenticated user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>A dictionary containing debug information or the first event.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.post(\"/debug-stream\")\nasync def debug_stream(\n    request: ChatRequest,\n    chat_service: Annotated[ChatService, Depends(get_chat_service)],\n    assistant_service: Annotated[AssistantService, Depends(get_assistant_service)],\n    user: Annotated[Optional[User], Depends(get_optional_user)],\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Debug version that returns full exceptions.\n\n    Args:\n        request: The chat request payload.\n        chat_service: The chat service instance.\n        assistant_service: The assistant service instance.\n        user: The optional authenticated user.\n\n    Returns:\n        A dictionary containing debug information or the first event.\n    \"\"\"\n    try:\n        assistant_uuid = request.assistant_id\n        assistant = await assistant_service.get_assistant_model(assistant_uuid)\n        if not assistant:\n            return {\"error\": \"Assistant not found\"}\n\n        user_id = str(user.id) if user else None\n\n        # Try to get first event\n        async for event in chat_service.stream_chat(\n            request.message,\n            assistant,\n            request.session_id,\n            language=request.language,\n            history=request.history,\n            user_id=user_id,\n        ):\n            return {\"success\": True, \"first_event\": event[:200]}\n    except Exception as e:\n        return {\n            \"error\": str(e),\n            \"type\": type(e).__name__,\n            \"traceback\": traceback.format_exc(),\n        }\n    return {\"error\": \"No events yielded\"}\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.get_chat_history","title":"<code>get_chat_history(session_id, chat_service, user)</code>  <code>async</code>","text":"<p>Retrieve conversation history for a specific session ID.</p> <p>Parameters:</p> <ul> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>The session ID to retrieve history for.</p> </li> <li> <code>chat_service</code>               (<code>Annotated[ChatService, Depends(get_chat_service)]</code>)           \u2013            <p>The chat service instance.</p> </li> <li> <code>user</code>               (<code>Annotated[Optional[User], Depends(get_optional_user)]</code>)           \u2013            <p>The optional authenticated user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, List[Dict[str, Any]]]</code>           \u2013            <p>A list of formatted chat messages.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.get(\"/{session_id}/history\")\nasync def get_chat_history(\n    session_id: str,\n    chat_service: Annotated[ChatService, Depends(get_chat_service)],\n    user: Annotated[Optional[User], Depends(get_optional_user)],\n) -&gt; Dict[str, List[Dict[str, Any]]]:\n    \"\"\"\n    Retrieve conversation history for a specific session ID.\n\n    Args:\n        session_id: The session ID to retrieve history for.\n        chat_service: The chat service instance.\n        user: The optional authenticated user.\n\n    Returns:\n        A list of formatted chat messages.\n    \"\"\"\n    try:\n        # Get history from the chat repository (Postgres) instead of Redis for full persistence\n        messages = await chat_service.chat_repository.get_messages(session_id)\n\n        # Transform to frontend-compatible format\n        formatted_messages = []\n        for msg in messages:\n            m = {\n                \"id\": str(msg.id),  # Use actual message UUID\n                \"text\": msg.content,\n                \"sender\": \"user\" if msg.role == \"user\" else \"bot\",\n            }\n            # Include metadata (visualization, sources, etc.)\n            if msg.metadata_:\n                meta = msg.metadata_.copy()\n\n                # Format Sources for Frontend (Source[] interface)\n                if \"sources\" in meta and isinstance(meta[\"sources\"], list):\n                    meta[\"sources\"] = [_format_source(s) for s in meta[\"sources\"]]\n\n                # Format Steps (Ensure labels are present)\n                if \"steps\" in meta and isinstance(meta[\"steps\"], list):\n                    meta[\"steps\"] = [_format_step(step) for step in meta[\"steps\"]]\n\n                # Format Visualization (Repair types if stringified by sanitization)\n                if \"visualization\" in meta and meta[\"visualization\"]:\n                    meta[\"visualization\"] = _format_visualization(meta[\"visualization\"])\n\n                m.update(meta)\n\n            formatted_messages.append(m)\n\n        return {\"messages\": formatted_messages}\n    except Exception as e:\n        logger.error(f\"Failed to retrieve history for session {session_id}: {e}\", exc_info=True)\n        # Don't fail hard - return empty history on error\n        return {\"messages\": []}\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.get_optional_user","title":"<code>get_optional_user(request, db)</code>  <code>async</code>","text":"<p>Resolves user from Bearer token if present, otherwise returns None.</p> <p>Does not raise 401 for invalid tokens, just returns None (for public access if allowed).</p> <p>Parameters:</p> <ul> <li> <code>request</code>               (<code>Request</code>)           \u2013            <p>The FastAPI request object.</p> </li> <li> <code>db</code>               (<code>Annotated[AsyncSession, Depends(get_db)]</code>)           \u2013            <p>The database session.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[User]</code>           \u2013            <p>The User object if found and valid, otherwise None.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>async def get_optional_user(request: Request, db: Annotated[AsyncSession, Depends(get_db)]) -&gt; Optional[User]:\n    \"\"\"\n    Resolves user from Bearer token if present, otherwise returns None.\n\n    Does not raise 401 for invalid tokens, just returns None (for public access if allowed).\n\n    Args:\n        request: The FastAPI request object.\n        db: The database session.\n\n    Returns:\n        The User object if found and valid, otherwise None.\n    \"\"\"\n    auth_header = request.headers.get(\"Authorization\")\n    if auth_header and auth_header.startswith(\"Bearer \"):\n        token = auth_header.split(\" \")[1]\n        try:\n            return await get_current_user(token=token, db=db)\n        except Exception:\n            return None\n    return None\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.ping","title":"<code>ping()</code>  <code>async</code>","text":"<p>Minimal test endpoint with zero dependencies.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>A dictionary with status and message.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.get(\"/ping\")\nasync def ping() -&gt; Dict[str, str]:\n    \"\"\"\n    Minimal test endpoint with zero dependencies.\n\n    Returns:\n        A dictionary with status and message.\n    \"\"\"\n    return {\"status\": \"ok\", \"message\": \"Backend is alive\"}\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.reset_chat_session","title":"<code>reset_chat_session(session_id, chat_service)</code>  <code>async</code>","text":"<p>Resets the conversation history for a specific session ID.</p> <p>Parameters:</p> <ul> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>The session ID to reset.</p> </li> <li> <code>chat_service</code>               (<code>Annotated[ChatService, Depends(get_chat_service)]</code>)           \u2013            <p>The chat service instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>A success message.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TechnicalError</code>             \u2013            <p>If resetting the conversation fails.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.delete(\"/{session_id}\")\nasync def reset_chat_session(\n    session_id: str, chat_service: Annotated[ChatService, Depends(get_chat_service)]\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Resets the conversation history for a specific session ID.\n\n    Args:\n        session_id: The session ID to reset.\n        chat_service: The chat service instance.\n\n    Returns:\n        A success message.\n\n    Raises:\n        TechnicalError: If resetting the conversation fails.\n    \"\"\"\n    try:\n        await chat_service.reset_conversation(session_id)\n        return {\"message\": \"Conversation history reset successfully\"}\n    except Exception as e:\n        logger.error(f\"Failed to reset conversation {session_id}: {e}\", exc_info=True)\n        if isinstance(e, (TechnicalError, FunctionalError)):\n            raise\n        raise TechnicalError(f\"Failed to reset conversation: {e}\")\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.test_assistant_svc","title":"<code>test_assistant_svc(assistant_service)</code>  <code>async</code>","text":"<p>Test if AssistantService injection works.</p> <p>Parameters:</p> <ul> <li> <code>assistant_service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>The assistant service instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>A dictionary with status and service info.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.get(\"/test-assistant-service\")\nasync def test_assistant_svc(\n    assistant_service: Annotated[AssistantService, Depends(get_assistant_service)],\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Test if AssistantService injection works.\n\n    Args:\n        assistant_service: The assistant service instance.\n\n    Returns:\n        A dictionary with status and service info.\n    \"\"\"\n    return {\"status\": \"ok\", \"service\": \"injected\"}\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.test_db","title":"<code>test_db(db)</code>  <code>async</code>","text":"<p>Test if DB injection works.</p> <p>Parameters:</p> <ul> <li> <code>db</code>               (<code>Annotated[AsyncSession, Depends(get_db)]</code>)           \u2013            <p>The database session.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>A dictionary with status and db info.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.get(\"/test-db\")\nasync def test_db(db: Annotated[AsyncSession, Depends(get_db)]) -&gt; Dict[str, str]:\n    \"\"\"\n    Test if DB injection works.\n\n    Args:\n        db: The database session.\n\n    Returns:\n        A dictionary with status and db info.\n    \"\"\"\n    return {\"status\": \"ok\", \"db\": \"connected\"}\n</code></pre>"},{"location":"api/v1/connectors/","title":"Connectors","text":"<p>Connectors API Endpoints.</p> <p>This module provides the API endpoints for managing connectors and their associated documents. Connectors are used to ingest data from various sources (SQL, files, etc.).</p>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.create_connector","title":"<code>create_connector(connector, service, current_user)</code>  <code>async</code>","text":"<p>Create a new connector.</p> <p>Parameters:</p> <ul> <li> <code>connector</code>               (<code>ConnectorCreate</code>)           \u2013            <p>The connector creation data.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorResponse</code> (              <code>ConnectorResponse</code> )          \u2013            <p>The created connector.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/\", response_model=ConnectorResponse)\nasync def create_connector(\n    connector: ConnectorCreate,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; ConnectorResponse:\n    \"\"\"\n    Create a new connector.\n\n    Args:\n        connector: The connector creation data.\n        service: The connector service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        ConnectorResponse: The created connector.\n    \"\"\"\n    return await service.create_connector(connector)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.create_connector_document","title":"<code>create_connector_document(connector_id, document, service, current_user)</code>  <code>async</code>","text":"<p>Manually add a document to a connector.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector.</p> </li> <li> <code>document</code>               (<code>ConnectorDocumentCreate</code>)           \u2013            <p>The document creation data.</p> </li> <li> <code>service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorDocumentResponse</code> (              <code>ConnectorDocumentResponse</code> )          \u2013            <p>The created document.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/documents\", response_model=ConnectorDocumentResponse)\nasync def create_connector_document(\n    connector_id: UUID,\n    document: ConnectorDocumentCreate,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; ConnectorDocumentResponse:\n    \"\"\"\n    Manually add a document to a connector.\n\n    Args:\n        connector_id: The ID of the connector.\n        document: The document creation data.\n        service: The document service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        ConnectorDocumentResponse: The created document.\n    \"\"\"\n    return await service.create_document(connector_id, document)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.delete_connector","title":"<code>delete_connector(connector_id, service, current_user)</code>  <code>async</code>","text":"<p>Delete a connector and its resources.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector to delete.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>Dict[str, str]: A success message.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.delete(\"/{connector_id}\")\nasync def delete_connector(\n    connector_id: UUID,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Delete a connector and its resources.\n\n    Args:\n        connector_id: The ID of the connector to delete.\n        service: The connector service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        Dict[str, str]: A success message.\n    \"\"\"\n    await service.delete_connector(connector_id)\n    return {\"message\": \"Connector deleted successfully\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.delete_document","title":"<code>delete_document(connector_id, document_id, service, current_user)</code>  <code>async</code>","text":"<p>Delete a specific document.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector.</p> </li> <li> <code>document_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the document to delete.</p> </li> <li> <code>service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>Dict[str, str]: A success message.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.delete(\"/{connector_id}/documents/{document_id}\")\nasync def delete_document(\n    connector_id: UUID,\n    document_id: UUID,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Delete a specific document.\n\n    Args:\n        connector_id: The ID of the connector.\n        document_id: The ID of the document to delete.\n        service: The document service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        Dict[str, str]: A success message.\n    \"\"\"\n    await service.delete_document(document_id)\n    return {\"message\": \"Document deleted successfully\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.get_connector_documents","title":"<code>get_connector_documents(connector_id, service, current_user, page=1, size=20, status=None, search=None)</code>  <code>async</code>","text":"<p>Get paginated documents for a connector.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector.</p> </li> <li> <code>service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> <li> <code>page</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The page number.</p> </li> <li> <code>size</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>The page size.</p> </li> <li> <code>status</code>               (<code>Optional[DocStatus]</code>, default:                   <code>None</code> )           \u2013            <p>Filter by document status.</p> </li> <li> <code>search</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Search term for file name or path.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Dict[str, Any]: Paginated document results.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.get(\"/{connector_id}/documents\", response_model=Dict[str, Any])\nasync def get_connector_documents(\n    connector_id: UUID,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n    page: int = 1,\n    size: int = 20,\n    status: Optional[DocStatus] = None,\n    search: Optional[str] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get paginated documents for a connector.\n\n    Args:\n        connector_id: The ID of the connector.\n        service: The document service instance.\n        current_user: The currently authenticated admin user.\n        page: The page number.\n        size: The page size.\n        status: Filter by document status.\n        search: Search term for file name or path.\n\n    Returns:\n        Dict[str, Any]: Paginated document results.\n    \"\"\"\n    result = await service.get_connector_documents(connector_id, page, size, status, search)\n    # The service already returns ConnectorDocumentResponse objects, but we ensure it here.\n    result[\"items\"] = [ConnectorDocumentResponse.model_validate(doc) for doc in result[\"items\"]]\n    return result\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.get_connectors","title":"<code>get_connectors(service, current_user)</code>  <code>async</code>","text":"<p>List all connectors.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[ConnectorResponse]</code>           \u2013            <p>List[ConnectorResponse]: A list of all connectors.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.get(\"/\", response_model=List[ConnectorResponse])\nasync def get_connectors(\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; List[ConnectorResponse]:\n    \"\"\"\n    List all connectors.\n\n    Args:\n        service: The connector service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        List[ConnectorResponse]: A list of all connectors.\n    \"\"\"\n    return await service.get_connectors()\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.scan_connector_files","title":"<code>scan_connector_files(connector_id, service, current_user)</code>  <code>async</code>","text":"<p>Trigger manual file scan for a folder connector.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector to scan.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorResponse</code> (              <code>ConnectorResponse</code> )          \u2013            <p>The connector being scanned.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/scan-files/\", response_model=ConnectorResponse)\n@router.post(\"/{connector_id}/scan-files\", response_model=ConnectorResponse)\nasync def scan_connector_files(\n    connector_id: UUID,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; ConnectorResponse:\n    \"\"\"\n    Trigger manual file scan for a folder connector.\n\n    Args:\n        connector_id: The ID of the connector to scan.\n        service: The connector service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        ConnectorResponse: The connector being scanned.\n    \"\"\"\n    return await service.scan_connector(connector_id)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.stop_connector","title":"<code>stop_connector(connector_id, service, current_user)</code>  <code>async</code>","text":"<p>Request to stop a running connector sync.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector to stop.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorResponse</code> (              <code>ConnectorResponse</code> )          \u2013            <p>The connector being stopped.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/stop\", response_model=ConnectorResponse)\nasync def stop_connector(\n    connector_id: UUID,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; ConnectorResponse:\n    \"\"\"\n    Request to stop a running connector sync.\n\n    Args:\n        connector_id: The ID of the connector to stop.\n        service: The connector service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        ConnectorResponse: The connector being stopped.\n    \"\"\"\n    return await service.stop_connector(connector_id)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.stop_document","title":"<code>stop_document(connector_id, document_id, service, current_user)</code>  <code>async</code>","text":"<p>Request to stop re-sync for a single document.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector.</p> </li> <li> <code>document_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the document to stop.</p> </li> <li> <code>service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>Dict[str, str]: A success message.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/documents/{document_id}/stop\")\nasync def stop_document(\n    connector_id: UUID,\n    document_id: UUID,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Request to stop re-sync for a single document.\n\n    Args:\n        connector_id: The ID of the connector.\n        document_id: The ID of the document to stop.\n        service: The document service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        Dict[str, str]: A success message.\n    \"\"\"\n    await service.stop_document(document_id)\n    return {\"message\": \"Document sync stop requested\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.sync_connector","title":"<code>sync_connector(connector_id, service, current_user, force=False)</code>  <code>async</code>","text":"<p>Trigger manual synchronization for a connector.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector to sync.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> <li> <code>force</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to force synchronization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorResponse</code> (              <code>ConnectorResponse</code> )          \u2013            <p>The connector being synced.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/sync\", response_model=ConnectorResponse)\nasync def sync_connector(\n    connector_id: UUID,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n    force: bool = False,\n) -&gt; ConnectorResponse:\n    \"\"\"\n    Trigger manual synchronization for a connector.\n\n    Args:\n        connector_id: The ID of the connector to sync.\n        service: The connector service instance.\n        current_user: The currently authenticated admin user.\n        force: Whether to force synchronization.\n\n    Returns:\n        ConnectorResponse: The connector being synced.\n    \"\"\"\n    connector = await service.trigger_sync(connector_id, force)\n    await manager.emit_trigger_connector_sync(str(connector_id))\n    return connector\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.sync_document","title":"<code>sync_document(connector_id, document_id, service, current_user)</code>  <code>async</code>","text":"<p>Trigger re-sync for a single document.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector.</p> </li> <li> <code>document_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the document to sync.</p> </li> <li> <code>service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>Dict[str, str]: A success message.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/documents/{document_id}/sync\")\nasync def sync_document(\n    connector_id: UUID,\n    document_id: UUID,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Trigger re-sync for a single document.\n\n    Args:\n        connector_id: The ID of the connector.\n        document_id: The ID of the document to sync.\n        service: The document service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        Dict[str, str]: A success message.\n    \"\"\"\n    await service.sync_document(document_id)\n    return {\"message\": \"Document sync queued\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.test_connection","title":"<code>test_connection(payload, service, sql_discovery_service, current_user)</code>  <code>async</code>","text":"<p>Test a connector connection (primarily for SQL).</p> <p>Parameters:</p> <ul> <li> <code>payload</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Dictionary containing connector_type and configuration.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>sql_discovery_service</code>               (<code>Annotated[Any, Depends(get_sql_discovery_service)]</code>)           \u2013            <p>The SQL discovery service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Dict[str, Any]: A success status and message.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/test-connection\")\nasync def test_connection(\n    payload: Dict[str, Any],\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    sql_discovery_service: Annotated[Any, Depends(get_sql_discovery_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Test a connector connection (primarily for SQL).\n\n    Args:\n        payload: Dictionary containing connector_type and configuration.\n        service: The connector service instance.\n        sql_discovery_service: The SQL discovery service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        Dict[str, Any]: A success status and message.\n    \"\"\"\n    connector_type = payload.get(\"connector_type\")\n    configuration = payload.get(\"configuration\")\n\n    if not connector_type or not configuration:\n        return {\"success\": False, \"message\": \"Missing connector_type or configuration\"}\n\n    if connector_type in [\"sql\", \"vanna_sql\"]:\n        try:\n            await sql_discovery_service.test_connection(configuration)\n            return {\"success\": True, \"message\": \"Connection successful\"}\n        except Exception as e:\n            logger.error(\"Connection test failed for %s: %s\", connector_type, e)\n            return {\"success\": False, \"message\": str(e)}\n\n    # Add other types if needed\n    return {\"success\": False, \"message\": f\"Connection test not implemented for {connector_type}\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.train_vanna_connector","title":"<code>train_vanna_connector(connector_id, payload, service, document_service, current_user)</code>  <code>async</code>","text":"<p>Train Vanna AI on specific documents (tables/views) for vanna_sql connector.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector.</p> </li> <li> <code>payload</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Dictionary containing <code>document_ids</code> list.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>document_service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Dict[str, Any]: A summary of the training results.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/train\")\nasync def train_vanna_connector(\n    connector_id: UUID,\n    payload: Dict[str, Any],\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    document_service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Train Vanna AI on specific documents (tables/views) for vanna_sql connector.\n\n    Args:\n        connector_id: The ID of the connector.\n        payload: Dictionary containing `document_ids` list.\n        service: The connector service instance.\n        document_service: The document service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        Dict[str, Any]: A summary of the training results.\n    \"\"\"\n    document_ids = payload.get(\"document_ids\", [])\n    if not document_ids:\n        return {\"success\": False, \"message\": \"document_ids array is required\"}\n\n    # Load connector\n    connector = await service.get_connector(connector_id)\n    if not connector:\n        return {\"success\": False, \"message\": \"Connector not found\"}\n\n    if connector.connector_type != \"vanna_sql\":\n        return {\"success\": False, \"message\": \"Training is only available for vanna_sql connectors\"}\n\n    try:\n        # Initialize Vanna service (Async Factory)\n        # P1: Local import to avoid missing dependency issues in some environments\n        from app.services.chat.vectra_vanna_service import VannaServiceFactory\n\n        vanna_svc = await VannaServiceFactory(service.settings_service)\n\n        trained_count = 0\n        failed_count = 0\n\n        # Train each document\n        for doc_id in document_ids:\n            try:\n                # Get document from repo via service\n                target_uuid = UUID(doc_id) if isinstance(doc_id, str) else doc_id\n                document = await document_service.document_repo.get_by_id(target_uuid)\n                if not document:\n                    logger.warning(\"Document %s not found, skipping\", doc_id)\n                    failed_count += 1\n                    continue\n\n                # Get DDL from file_metadata\n                ddl_content = (document.file_metadata or {}).get(\"ddl\")\n                if not ddl_content:\n                    logger.warning(\"Document %s has no DDL content, skipping\", doc_id)\n                    failed_count += 1\n                    continue\n\n                # Train Vanna with document's DDL content\n                await asyncio.to_thread(vanna_svc.train, ddl=ddl_content)\n\n                # Mark as trained in metadata\n                meta = document.file_metadata or {}\n                meta[\"trained\"] = True\n                meta[\"trained_at\"] = datetime.utcnow().isoformat()\n\n                # Update document\n                await document_service.update_document(document.id, {\"file_metadata\": meta})\n\n                trained_count += 1\n                logger.info(\"Trained Vanna on document: %s\", document.file_name)\n\n            except Exception as doc_error:\n                logger.error(\"Failed to train document %s: %s\", doc_id, doc_error)\n                failed_count += 1\n\n        return {\n            \"success\": True,\n            \"message\": f\"Training completed. {trained_count} documents trained, {failed_count} failed.\",\n            \"trained_count\": trained_count,\n            \"failed_count\": failed_count,\n        }\n    except Exception as e:\n        logger.error(\"Training failed: %s\", e, exc_info=True)\n        return {\"success\": False, \"message\": f\"Training failed: {str(e)}\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.update_connector","title":"<code>update_connector(connector_id, connector, service, current_user)</code>  <code>async</code>","text":"<p>Update an existing connector.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector to update.</p> </li> <li> <code>connector</code>               (<code>ConnectorUpdate</code>)           \u2013            <p>The connector update data.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorResponse</code> (              <code>ConnectorResponse</code> )          \u2013            <p>The updated connector.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.put(\"/{connector_id}\", response_model=ConnectorResponse)\nasync def update_connector(\n    connector_id: UUID,\n    connector: ConnectorUpdate,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; ConnectorResponse:\n    \"\"\"\n    Update an existing connector.\n\n    Args:\n        connector_id: The ID of the connector to update.\n        connector: The connector update data.\n        service: The connector service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        ConnectorResponse: The updated connector.\n    \"\"\"\n    return await service.update_connector(connector_id, connector)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.update_document","title":"<code>update_document(connector_id, document_id, document, service, current_user)</code>  <code>async</code>","text":"<p>Update a specific document.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector.</p> </li> <li> <code>document_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the document to update.</p> </li> <li> <code>document</code>               (<code>ConnectorDocumentUpdate</code>)           \u2013            <p>The document update data.</p> </li> <li> <code>service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorDocumentResponse</code> (              <code>ConnectorDocumentResponse</code> )          \u2013            <p>The updated document.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.put(\"/{connector_id}/documents/{document_id}\", response_model=ConnectorDocumentResponse)\nasync def update_document(\n    connector_id: UUID,\n    document_id: UUID,\n    document: ConnectorDocumentUpdate,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; ConnectorDocumentResponse:\n    \"\"\"\n    Update a specific document.\n\n    Args:\n        connector_id: The ID of the connector.\n        document_id: The ID of the document to update.\n        document: The document update data.\n        service: The document service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        ConnectorDocumentResponse: The updated document.\n    \"\"\"\n    return await service.update_document(document_id, document)\n</code></pre>"},{"location":"api/v1/dashboard/","title":"Dashboard","text":"<p>Dashboard Statistics API Endpoint.</p> <p>Provides REST endpoint for dashboard stats and manages periodic WebSocket broadcasts.</p>"},{"location":"api/v1/dashboard/#app.api.v1.endpoints.dashboard.broadcast_dashboard_stats_loop","title":"<code>broadcast_dashboard_stats_loop(interval_seconds=5)</code>  <code>async</code>","text":"<p>Background task that periodically broadcasts dashboard stats via WebSocket.</p> <p>Parameters:</p> <ul> <li> <code>interval_seconds</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Broadcast interval in seconds (default: 5).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>app/api/v1/endpoints/dashboard.py</code> <pre><code>async def broadcast_dashboard_stats_loop(interval_seconds: int = 5) -&gt; None:\n    \"\"\"\n    Background task that periodically broadcasts dashboard stats via WebSocket.\n\n    Args:\n        interval_seconds: Broadcast interval in seconds (default: 5).\n\n    Returns:\n        None\n    \"\"\"\n    global _broadcast_running\n    _broadcast_running = True\n\n    logger.info(\"Starting dashboard stats broadcast loop (interval: %ds)\", interval_seconds)\n\n    # Import here to avoid circular dependency\n    from app.core.connection_manager import manager\n    from app.core.database import SessionLocal\n\n    while _broadcast_running:\n        try:\n            # Create a new database session for this iteration\n            async with SessionLocal() as db:\n                service = DashboardStatsService(db)\n                stats = await service.get_all_stats()\n\n                # Broadcast via WebSocket\n                await manager.emit_dashboard_stats(stats.model_dump(mode=\"json\"))\n\n        except Exception as e:\n            logger.error(\"Error in dashboard stats broadcast: %s\", e, exc_info=True)\n\n        # Wait for next interval\n        await asyncio.sleep(interval_seconds)\n\n    logger.info(\"Dashboard stats broadcast loop stopped\")\n</code></pre>"},{"location":"api/v1/dashboard/#app.api.v1.endpoints.dashboard.get_dashboard_stats","title":"<code>get_dashboard_stats(db)</code>  <code>async</code>","text":"<p>Get current dashboard statistics (REST endpoint).</p> <p>This provides a synchronous way to fetch stats without WebSocket.</p> <p>Parameters:</p> <ul> <li> <code>db</code>               (<code>Annotated[AsyncSession, Depends(get_db)]</code>)           \u2013            <p>Database session.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DashboardStats</code> (              <code>DashboardStats</code> )          \u2013            <p>The current dashboard statistics.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/dashboard.py</code> <pre><code>@router.get(\"/stats\", response_model=DashboardStats)\nasync def get_dashboard_stats(db: Annotated[AsyncSession, Depends(get_db)]) -&gt; DashboardStats:\n    \"\"\"\n    Get current dashboard statistics (REST endpoint).\n\n    This provides a synchronous way to fetch stats without WebSocket.\n\n    Args:\n        db: Database session.\n\n    Returns:\n        DashboardStats: The current dashboard statistics.\n    \"\"\"\n    service = DashboardStatsService(db)\n    stats = await service.get_all_stats()\n    return stats\n</code></pre>"},{"location":"api/v1/dashboard/#app.api.v1.endpoints.dashboard.start_broadcast_task","title":"<code>start_broadcast_task(interval_seconds=5)</code>  <code>async</code>","text":"<p>Start the periodic broadcast background task.</p> <p>Parameters:</p> <ul> <li> <code>interval_seconds</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Broadcast interval in seconds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>app/api/v1/endpoints/dashboard.py</code> <pre><code>async def start_broadcast_task(interval_seconds: int = 5) -&gt; None:\n    \"\"\"\n    Start the periodic broadcast background task.\n\n    Args:\n        interval_seconds: Broadcast interval in seconds.\n\n    Returns:\n        None\n    \"\"\"\n    global _broadcast_task, _broadcast_running\n\n    if _broadcast_task is not None and not _broadcast_task.done():\n        logger.warning(\"Dashboard broadcast task already running\")\n        return\n\n    _broadcast_running = True\n    _broadcast_task = asyncio.create_task(broadcast_dashboard_stats_loop(interval_seconds))\n    logger.info(\"Dashboard broadcast task started\")\n</code></pre>"},{"location":"api/v1/dashboard/#app.api.v1.endpoints.dashboard.stop_broadcast_task","title":"<code>stop_broadcast_task()</code>  <code>async</code>","text":"<p>Stop the periodic broadcast background task.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>app/api/v1/endpoints/dashboard.py</code> <pre><code>async def stop_broadcast_task() -&gt; None:\n    \"\"\"\n    Stop the periodic broadcast background task.\n\n    Returns:\n        None\n    \"\"\"\n    global _broadcast_task, _broadcast_running\n\n    if _broadcast_task is None:\n        return\n\n    _broadcast_running = False\n\n    # Wait for task to finish (should exit quickly after flag set)\n    try:\n        if _broadcast_task:\n            await asyncio.wait_for(_broadcast_task, timeout=10.0)\n    except (asyncio.TimeoutError, asyncio.CancelledError):\n        if _broadcast_task:\n            logger.warning(\"Dashboard broadcast task did not stop gracefully, cancelling\")\n            _broadcast_task.cancel()\n\n    _broadcast_task = None\n    logger.info(\"Dashboard broadcast task stopped\")\n</code></pre>"},{"location":"api/v1/users/","title":"Users","text":""},{"location":"api/v1/users/#app.api.v1.endpoints.users.create_user","title":"<code>create_user(*, user_in, service, current_admin)</code>  <code>async</code>","text":"<p>Create new user. Admin only.</p> <p>Parameters:</p> <ul> <li> <code>user_in</code>               (<code>UserCreate</code>)           \u2013            <p>The user creation data.</p> </li> <li> <code>service</code>               (<code>Annotated[UserService, Depends(get_user_service)]</code>)           \u2013            <p>The user service instance.</p> </li> <li> <code>current_admin</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The created user object.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.post(\"/\", response_model=UserRead)\nasync def create_user(\n    *,\n    user_in: UserCreate,\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n) -&gt; Any:\n    \"\"\"\n    Create new user. Admin only.\n\n    Args:\n        user_in: The user creation data.\n        service: The user service instance.\n        current_admin: The currently authenticated admin user.\n\n    Returns:\n        Any: The created user object.\n    \"\"\"\n    return await service.create(user_in)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.delete_user","title":"<code>delete_user(*, user_id, service, current_admin)</code>  <code>async</code>","text":"<p>Delete a user. Admin only.</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the user to delete.</p> </li> <li> <code>service</code>               (<code>Annotated[UserService, Depends(get_user_service)]</code>)           \u2013            <p>The user service instance.</p> </li> <li> <code>current_admin</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The deleted user object.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.delete(\"/{user_id}\", response_model=UserRead)\nasync def delete_user(\n    *,\n    user_id: UUID,\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n) -&gt; Any:\n    \"\"\"\n    Delete a user. Admin only.\n\n    Args:\n        user_id: The ID of the user to delete.\n        service: The user service instance.\n        current_admin: The currently authenticated admin user.\n\n    Returns:\n        Any: The deleted user object.\n    \"\"\"\n    return await service.delete(user_id)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.delete_user_avatar","title":"<code>delete_user_avatar(*, user_id, service, current_user)</code>  <code>async</code>","text":"<p>Remove the avatar image from a user.</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the user.</p> </li> <li> <code>service</code>               (<code>Annotated[UserService, Depends(get_user_service)]</code>)           \u2013            <p>The user service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_user)]</code>)           \u2013            <p>The currently authenticated user.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>If the user is not authorized.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The updated user object.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.delete(\"/{user_id}/avatar\", response_model=UserRead)\nasync def delete_user_avatar(\n    *,\n    user_id: UUID,\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -&gt; Any:\n    \"\"\"\n    Remove the avatar image from a user.\n\n    Args:\n        user_id: The ID of the user.\n        service: The user service instance.\n        current_user: The currently authenticated user.\n\n    Raises:\n        HTTPException: If the user is not authorized.\n\n    Returns:\n        Any: The updated user object.\n    \"\"\"\n    if current_user.id != user_id and current_user.role != UserRole.ADMIN:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    return await service.remove_avatar(user_id)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.get_user_avatar","title":"<code>get_user_avatar(*, user_id, service)</code>  <code>async</code>","text":"<p>Get the avatar image file for a user.</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the user.</p> </li> <li> <code>service</code>               (<code>Annotated[UserService, Depends(get_user_service)]</code>)           \u2013            <p>The user service instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>If the avatar is not found.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FileResponse</code> (              <code>Any</code> )          \u2013            <p>The avatar image file.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.get(\"/{user_id}/avatar\")\nasync def get_user_avatar(\n    *,\n    user_id: UUID,\n    service: Annotated[UserService, Depends(get_user_service)],\n) -&gt; Any:\n    \"\"\"\n    Get the avatar image file for a user.\n\n    Args:\n        user_id: The ID of the user.\n        service: The user service instance.\n\n    Raises:\n        HTTPException: If the avatar is not found.\n\n    Returns:\n        FileResponse: The avatar image file.\n    \"\"\"\n    file_path = await service.get_avatar_path(user_id)\n    if not file_path:\n        raise HTTPException(status_code=404, detail=\"Avatar not found\")\n\n    return FileResponse(file_path)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.read_user_me","title":"<code>read_user_me(current_user)</code>  <code>async</code>","text":"<p>Get current user.</p> <p>Parameters:</p> <ul> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_user)]</code>)           \u2013            <p>The currently authenticated user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The current user object.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.get(\"/me\", response_model=UserRead)\nasync def read_user_me(current_user: Annotated[User, Depends(get_current_user)]) -&gt; Any:\n    \"\"\"\n    Get current user.\n\n    Args:\n        current_user: The currently authenticated user.\n\n    Returns:\n        Any: The current user object.\n    \"\"\"\n    return current_user\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.read_users","title":"<code>read_users(service, current_admin, skip=0, limit=100)</code>  <code>async</code>","text":"<p>Retrieve users. Admin only.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[UserService, Depends(get_user_service)]</code>)           \u2013            <p>The user service instance.</p> </li> <li> <code>current_admin</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> <li> <code>skip</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of records to skip.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>Maximum number of records to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>A list of users.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.get(\"/\", response_model=List[UserRead])\nasync def read_users(\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n    skip: int = 0,\n    limit: int = 100,\n) -&gt; Any:\n    \"\"\"\n    Retrieve users. Admin only.\n\n    Args:\n        service: The user service instance.\n        current_admin: The currently authenticated admin user.\n        skip: Number of records to skip.\n        limit: Maximum number of records to return.\n\n    Returns:\n        Any: A list of users.\n    \"\"\"\n    return await service.get_multi(skip=skip, limit=limit)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.update_user","title":"<code>update_user(*, user_id, user_in, service, current_admin)</code>  <code>async</code>","text":"<p>Update a user. Admin only.</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the user to update.</p> </li> <li> <code>user_in</code>               (<code>UserUpdate</code>)           \u2013            <p>The user update data.</p> </li> <li> <code>service</code>               (<code>Annotated[UserService, Depends(get_user_service)]</code>)           \u2013            <p>The user service instance.</p> </li> <li> <code>current_admin</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The updated user object.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.patch(\"/{user_id}\", response_model=UserRead)\nasync def update_user(\n    *,\n    user_id: UUID,\n    user_in: UserUpdate,\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n) -&gt; Any:\n    \"\"\"\n    Update a user. Admin only.\n\n    Args:\n        user_id: The ID of the user to update.\n        user_in: The user update data.\n        service: The user service instance.\n        current_admin: The currently authenticated admin user.\n\n    Returns:\n        Any: The updated user object.\n    \"\"\"\n    return await service.update(user_id, user_in)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.upload_user_avatar","title":"<code>upload_user_avatar(*, user_id, file=File(...), service, current_user)</code>  <code>async</code>","text":"<p>Upload an avatar image for a user.</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the user.</p> </li> <li> <code>file</code>               (<code>UploadFile</code>, default:                   <code>File(...)</code> )           \u2013            <p>The avatar image file to upload.</p> </li> <li> <code>service</code>               (<code>Annotated[UserService, Depends(get_user_service)]</code>)           \u2013            <p>The user service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_user)]</code>)           \u2013            <p>The currently authenticated user.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>If the user is not authorized.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The updated user object.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.post(\"/{user_id}/avatar\", response_model=UserRead)\nasync def upload_user_avatar(\n    *,\n    user_id: UUID,\n    file: UploadFile = File(...),\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -&gt; Any:\n    \"\"\"\n    Upload an avatar image for a user.\n\n    Args:\n        user_id: The ID of the user.\n        file: The avatar image file to upload.\n        service: The user service instance.\n        current_user: The currently authenticated user.\n\n    Raises:\n        HTTPException: If the user is not authorized.\n\n    Returns:\n        Any: The updated user object.\n    \"\"\"\n    if current_user.id != user_id and current_user.role != UserRole.ADMIN:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    return await service.upload_avatar(user_id, file)\n</code></pre>"},{"location":"api/v1/ws/","title":"WebSockets","text":"<p>WebSocket API endpoints for the Vectra backend.</p> <p>This module provides the WebSocket endpoint for both frontend clients and the Python worker, handling real-time communication and status updates.</p>"},{"location":"api/v1/ws/#app.api.v1.ws.ClientType","title":"<code>ClientType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enumeration for different types of WebSocket clients.</p> <p>Attributes:</p> <ul> <li> <code>CLIENT</code>           \u2013            <p>Represents a frontend client (e.g., React Dashboard).</p> </li> <li> <code>WORKER</code>           \u2013            <p>Represents the backend Python worker.</p> </li> </ul> Source code in <code>app/api/v1/ws.py</code> <pre><code>class ClientType(StrEnum):\n    \"\"\"\n    Enumeration for different types of WebSocket clients.\n\n    Attributes:\n        CLIENT: Represents a frontend client (e.g., React Dashboard).\n        WORKER: Represents the backend Python worker.\n    \"\"\"\n\n    CLIENT = \"client\"\n    WORKER = \"worker\"\n</code></pre>"},{"location":"api/v1/ws/#app.api.v1.ws.websocket_endpoint","title":"<code>websocket_endpoint(websocket, manager, client_type=Query(ClientType.CLIENT), token=Query(default=None))</code>  <code>async</code>","text":"<p>WebSocket Endpoint handling both Frontend clients and the Python Worker.</p> <p>This endpoint manages the lifecycle of WebSocket connections, including handshake, security checks, message processing, and disconnection. Workers must provide valid authentication using a secret token.</p> <p>Protocol: - Frontend clients connect with <code>client_type=client</code>. - Workers connect with <code>client_type=worker</code> and must provide <code>x-worker-secret</code>   header or a <code>token</code> query parameter matching <code>settings.WORKER_SECRET</code>.</p> <p>Parameters:</p> <ul> <li> <code>websocket</code>               (<code>WebSocket</code>)           \u2013            <p>The WebSocket connection instance.</p> </li> <li> <code>manager</code>               (<code>Annotated[ConnectionManager, Depends(get_connection_manager)]</code>)           \u2013            <p>Singleton manager for handling active connections.</p> </li> <li> <code>client_type</code>               (<code>ClientType</code>, default:                   <code>Query(CLIENT)</code> )           \u2013            <p>Type of the connecting client (client or worker). Defaults to ClientType.CLIENT.</p> </li> <li> <code>token</code>               (<code>Optional[str]</code>, default:                   <code>Query(default=None)</code> )           \u2013            <p>Optional authentication token (used if x-worker-secret header is missing).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>WebSocketDisconnect</code>             \u2013            <p>When the client disconnects normally.</p> </li> </ul> Source code in <code>app/api/v1/ws.py</code> <pre><code>@router.websocket(\"/ws\")\nasync def websocket_endpoint(\n    websocket: WebSocket,\n    manager: Annotated[ConnectionManager, Depends(get_connection_manager)],\n    client_type: ClientType = Query(ClientType.CLIENT),\n    token: Optional[str] = Query(default=None),\n) -&gt; None:\n    \"\"\"\n    WebSocket Endpoint handling both Frontend clients and the Python Worker.\n\n    This endpoint manages the lifecycle of WebSocket connections, including\n    handshake, security checks, message processing, and disconnection.\n    Workers must provide valid authentication using a secret token.\n\n    Protocol:\n    - Frontend clients connect with `client_type=client`.\n    - Workers connect with `client_type=worker` and must provide `x-worker-secret`\n      header or a `token` query parameter matching `settings.WORKER_SECRET`.\n\n    Args:\n        websocket: The WebSocket connection instance.\n        manager: Singleton manager for handling active connections.\n        client_type: Type of the connecting client (client or worker).\n            Defaults to ClientType.CLIENT.\n        token: Optional authentication token (used if x-worker-secret header is missing).\n\n    Returns:\n        None\n\n    Raises:\n        WebSocketDisconnect: When the client disconnects normally.\n    \"\"\"\n    func_name: str = \"websocket_endpoint\"\n\n    logger.debug(f\"CONNECT | {func_name} | Incoming connection [Type: {client_type}]\")\n\n    # 1. Connection Phase &amp; Authentication\n    try:\n        if client_type == ClientType.WORKER:\n            # Extract secret from headers or query param\n            secret: Optional[str] = websocket.headers.get(\"x-worker-secret\")\n\n            if not secret and token:\n                secret = token\n\n            # Securely compare secrets to prevent timing attacks\n            expected_secret = str(settings.WORKER_SECRET)\n            if not secret or not secrets.compare_digest(secret, expected_secret):\n                logger.warning(\n                    f\"SECURITY | {func_name} | Unauthorized Worker Attempt. \"\n                    f\"Received: {secret!r} | Expected: [REDACTED]\"\n                )\n                await websocket.close(code=status.WS_1008_POLICY_VIOLATION)\n                return\n\n        # Accept connection and add to manager\n        await manager.connect(websocket)\n\n        conn_id: str = str(getattr(websocket, \"conn_id\", \"unknown\"))\n        if client_type == ClientType.WORKER:\n            logger.info(f\"START | {func_name} | Secure Worker Connected [ID: {conn_id}]\")\n            await manager.register_worker(websocket)\n        else:\n            logger.debug(f\"START | {func_name} | Client Connected [ID: {conn_id}]\")\n\n    except Exception as e:\n        logger.error(f\"FAIL | {func_name} | Connection refused or failed during setup | Error: {e}\", exc_info=True)\n        return\n\n    # 2. Communication Loop\n    try:\n        while True:\n            # Wait for text messages\n            data: str = await websocket.receive_text()\n\n            # Heartbeat check\n            if data == \"ping\":\n                await websocket.send_text(\"pong\")\n                continue\n\n            # Status request\n            if data == \"get_worker_status\":\n                await manager.emit_worker_status(manager.is_worker_online)\n                continue\n\n            # Worker Broadcast: Re-broadcast worker messages to all frontend clients\n            if client_type == ClientType.WORKER:\n                try:\n                    payload: Any = json.loads(data)\n                    if isinstance(payload, dict):\n                        await manager.broadcast(payload)\n                    else:\n                        logger.warning(f\"Context | {func_name} | Msg: Worker sent non-dictionary JSON: {type(payload)}\")\n                except json.JSONDecodeError as e:\n                    logger.warning(f\"Context | {func_name} | Msg: Invalid JSON from worker | Error: {e!r}\")\n                except Exception as e:\n                    logger.error(\n                        f\"FAIL | {func_name} | Worker broadcast error | Error: {e}\",\n                        exc_info=True,\n                    )\n\n    except WebSocketDisconnect as e:\n        logger.info(f\"FINISH | {func_name} | {client_type} Disconnected [Code: {e.code}]\")\n    except Exception as e:\n        logger.error(f\"FAIL | {func_name} | Unexpected error in WS loop | Error: {e!r}\", exc_info=True)\n    finally:\n        # 3. Cleanup Phase\n        try:\n            await manager.disconnect(websocket)\n        except Exception as e:\n            logger.debug(f\"Cleanup | {func_name} | Disconnect failed (likely already closed) | Error: {e}\")\n</code></pre>"}]}