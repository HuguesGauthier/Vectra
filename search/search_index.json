{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83e\udde0 Vectra: The Agentic RAG Assistant","text":"<p>Democratize access to corporate data through a unified, intuitive chat interface.</p> <p>Vectra is an Agentic RAG Assistant that unifies structured (SQL) and unstructured (Documents) data. It acts as your company's collective memory, making specialized expertise accessible to everyone, 24/7.</p>"},{"location":"#key-value-propositions","title":"\ud83d\ude80 Key Value Propositions","text":"<ul> <li>Knowledge Decentralization: Offload \"human knowledge hubs\" by making specialized expertise accessible without constant interruptions.</li> <li>Document Omniscience: Indexes PDFs and the entire Microsoft Office suite (Word, Excel, PowerPoint) to provide context-aware answers.</li> <li>Operational Agility: Converts complex business questions into instant SQL queries, bypassing the need for IT/BI tickets.</li> </ul>"},{"location":"#why-vectra","title":"\u2728 Why Vectra?","text":"<ul> <li>Hybrid Intelligence: Automatically routes queries between structured data (AI Analyst) and documents (Vector Search).</li> <li>Model Agnostic: Compatible with Gemini, OpenAI, Mistral, and Ollama for local, secure inference.</li> <li>Enterprise-Ready: Self-hosted and secure Docker-first architecture ensuring full control over your sensitive data.</li> <li>Premium UI: Seamless experience with streaming responses, interactive charts, and precise source citations.</li> </ul>"},{"location":"#get-started","title":"\ud83c\udfc1 Get Started","text":"<p>Explore the documentation to discover how to deploy Vectra and connect your knowledge bases.</p> <ul> <li>Installation Guide: Launch your instance in minutes with Docker.</li> <li>Configuration: Set up your environment variables and AI models.</li> <li>Architecture: Dive into the technical details of the hybrid stack.</li> <li>API Reference: Integrate Vectra features into your own applications.</li> </ul> <p> Powered by FastAPI, Vue 3, and state-of-the-art AI orchestration. </p>"},{"location":"architecture/","title":"Vectra Architecture","text":"<p>Vectra is an Agentic RAG Assistant designed to unify structured (SQL) and unstructured (Documents) data into a single, intuitive chat interface.</p>"},{"location":"architecture/#hybrid-architecture","title":"Hybrid Architecture","text":"<p>Vectra relies on a powerful dual-engine architecture:</p> <ol> <li>AI Analyst (Vanna.ai): An intelligent agent that generates SQL on-the-fly to answer ad-hoc questions and explore structured databases in real-time.</li> <li>Vector Search (LlamaIndex): Retrieves precise answers from internal wikis and documents (PDF, Word, Excel, PowerPoint) via Qdrant.</li> </ol> <pre><code>graph TD\n    User([User]) &lt;--&gt; Frontend[Frontend Vue.js/Quasar]\n    Frontend &lt;--&gt; API[FastAPI Backend]\n\n    subgraph \"Hybrid Core\"\n        API &lt;--&gt; AI_Analyst[AI Analyst / Vanna.ai]\n        API &lt;--&gt; RAG[Vector Search / LlamaIndex]\n    end\n\n    AI_Analyst &lt;--&gt; SQL_DB[(Structured DB / Postgres, SQL Server...)]\n    RAG &lt;--&gt; Qdrant[(Vector DB / Qdrant)]\n\n    API &lt;--&gt; Redis[(Redis Cache)]\n    API -- Ingestion triggers --&gt; Worker[Background Worker]\n    Worker -- Processing --&gt; Qdrant</code></pre>"},{"location":"architecture/#main-components","title":"Main Components","text":""},{"location":"architecture/#1-backend-api-fastapi","title":"1. Backend API (FastAPI)","text":"<p>The central orchestrator of the system:</p> <ul> <li>Smart Routing: Automatically detects user intent to route queries to either the AI Analyst or the Vector Search engine.</li> <li>Deep Chat UI Orchestration: Manages streaming responses and interactive chart rendering.</li> <li>Security: JWT-based enterprise-grade authentication.</li> </ul>"},{"location":"architecture/#2-ai-analyst-vannaai","title":"2. AI Analyst (Vanna.ai)","text":"<p>Specialized in translating natural language into precise SQL queries. It allows for real-time exploration of structured data without pre-defined reports.</p>"},{"location":"architecture/#3-vector-search-llamaindex-qdrant","title":"3. Vector Search (LlamaIndex &amp; Qdrant)","text":"<p>The backbone for unstructured data retrieval. It indexes and searches through your company's documents, acting as a \"collective memory\".</p>"},{"location":"architecture/#4-background-worker","title":"4. Background Worker","text":"<p>Handles multimodal data ingestion and heavy vectorization workloads, ensuring the knowledge base is always up-to-date.</p>"},{"location":"architecture/#security-privacy","title":"Security &amp; Privacy","text":"<ul> <li>Self-Hosted: Full control over your data; sensitive information never leaves your infrastructure.</li> <li>Model Agnostic: Compatible with Gemini, OpenAI, Mistral, and Ollama (local inference).</li> </ul>"},{"location":"architecture/#data-flow","title":"Data Flow","text":"<ol> <li>User Request: The user sends a natural language query.</li> <li>Intent Analysis: The API determines if the answer lies in structured databases or unstructured documents.</li> <li>Execution:</li> <li>SQL Path: Vanna.ai generates and executes SQL.</li> <li>Vector Path: LlamaIndex performs semantic search in Qdrant.</li> <li>Response Synthesis: The LLM compiles the findings into a sourced and clear response.</li> <li>Streaming: Results are streamed back to the UI in real-time.</li> </ol>"},{"location":"config/","title":"Configuration","text":"<p>Vectra uses environment variables for its configuration. Most of these can be set in a <code>.env</code> file at the root of the project.</p>"},{"location":"config/#core-settings","title":"Core Settings","text":"Variable Description Default <code>ENV</code> Environment (development, production) <code>development</code> <code>SECRET_KEY</code> Secret key for JWT authentication (Required) <code>DATABASE_URL</code> SQLAlchemy URL for the PostgreSQL database (Required) <code>QDRANT_HOST</code> Hostname for the Qdrant vector database <code>localhost</code> <code>REDIS_HOST</code> Hostname for the Redis cache/queue <code>localhost</code>"},{"location":"config/#ai-providers","title":"AI Providers","text":"<p>Vectra supports multiple LLM and Embedding providers:</p> <ul> <li>Gemini: <code>GEMINI_API_KEY</code></li> <li>OpenAI: <code>OPENAI_API_KEY</code></li> <li>Mistral: <code>MISTRAL_API_KEY</code></li> <li>Ollama: <code>OLLAMA_BASE_URL</code> (usually <code>http://localhost:11434</code>)</li> </ul>"},{"location":"config/#data-persistence-docker","title":"Data Persistence (Docker)","text":"<p>To allow Vectra to access your local folders when running in Docker, you must define the mapping:</p> <pre><code># The physical path on your host machine\nVECTRA_DATA_PATH=D:/MyDocuments\n</code></pre> <p>Any Connector path starting with this value will be correctly mapped to the internal Docker <code>/data</code> volume.</p>"},{"location":"config/#initial-setup","title":"Initial Setup","text":"<p>On first startup, Vectra can automatically create a superuser:</p> <pre><code>FIRST_SUPERUSER=admin@vectra.ai\nFIRST_SUPERUSER_PASSWORD=secure_password_here\n</code></pre> <p>[!TIP] For a complete list of available settings and their meanings, please refer to the app/core/settings.py file.</p>"},{"location":"install/","title":"Installation","text":"<p>Vectra can be deployed quickly via Docker (recommended) or manually for development.</p>"},{"location":"install/#quick-start-docker","title":"\ud83d\ude80 Quick Start (Docker)","text":"<p>Get Vectra running in 2 minutes:</p> <ol> <li>Clone the project:</li> </ol> <pre><code>git clone https://github.com/HuguesGauthier/Vectra.git\ncd Vectra\n</code></pre> <ol> <li>Configure environment:</li> </ol> <pre><code>cp .env.example .env\n# Edit the .env file with your API keys (Gemini, etc.)\n</code></pre> <ol> <li>Launch services:    <pre><code>docker-compose up -d\n</code></pre></li> </ol> <p>Access the UI at: http://localhost:9000</p>"},{"location":"install/#data-persistence-docker","title":"Data Persistence (Docker)","text":"<p>To allows Vectra to access your local files and folders in Docker:</p> <ol> <li>Define the base path of your documents in your <code>.env</code>:    <pre><code>VECTRA_DATA_PATH=D:/MyDocuments\n</code></pre></li> <li>Any connector created with a path starting with <code>D:/MyDocuments</code> will be automatically mapped to the internal Docker <code>/data</code> volume.</li> </ol>"},{"location":"install/#environments-setup","title":"\ud83c\udfd7\ufe0f Environments Setup","text":"<p>Vectra supports multiple environments using Docker Compose profiles.</p>"},{"location":"install/#hybrid-development-recommended","title":"\ud83d\udee0\ufe0f Hybrid Development (Recommended)","text":"<p>This mode runs the Infrastructure (Postgres, Qdrant, Redis, Ollama) in Docker and your Application code locally for better performance and debugging.</p> <ol> <li>Launch Infrastructure:    <pre><code># Launches only the databases and infra services\ndocker compose up -d\n</code></pre></li> <li>Launch Backend:    <pre><code>cd backend\npip install -r requirements.txt\npython main.py\n</code></pre></li> <li>Launch Frontend:    <pre><code>cd frontend\nnpm install\nnpm run dev\n</code></pre></li> </ol>"},{"location":"install/#production-full-docker","title":"\ud83d\ude80 Production (Full Docker)","text":"<p>This mode builds and runs everything inside optimized Docker containers. It doesn't rely on local code once built.</p> <pre><code># Use --profile prod to include the application services\ndocker compose --profile prod -f docker-compose.yml -f docker-compose.prod.yml up -d --build\n</code></pre> <ul> <li>Frontend: http://localhost (Port 80)</li> <li>Backend API: http://localhost:8000</li> </ul>"},{"location":"install/#license","title":"\ud83d\udcdc License","text":"<p>Vectra is open-source software licensed under the GNU AGPL v3.</p> <p>[!IMPORTANT] The AGPL v3 is a \"strong copyleft\" license. If you modify Vectra or use it to provide a service over a network, you must make your modified source code available to the users of that service.</p>"},{"location":"install/#commercial-use","title":"\ud83d\udcbc Commercial Use","text":"<p>If you wish to:</p> <ul> <li>Integrate Vectra into a proprietary software product.</li> <li>Build a commercial SaaS without releasing your own source code.</li> <li>Benefit from Enterprise Support and priority features.</li> </ul> <p>You must purchase a Commercial License. Please contact the author for enterprise pricing and licensing options.</p>"},{"location":"api/v1/analytics/","title":"Analytics","text":"<p>Advanced Analytics API Endpoints.</p>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.broadcast_analytics_loop","title":"<code>broadcast_analytics_loop(interval_seconds=10)</code>  <code>async</code>","text":"<p>Background task that periodically broadcasts advanced analytics stats via WebSocket.</p> <p>Parameters:</p> <ul> <li> <code>interval_seconds</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Broadcast interval in seconds (default: 10). Higher than dashboard stats due to query complexity.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>async def broadcast_analytics_loop(interval_seconds: int = 10) -&gt; None:\n    \"\"\"\n    Background task that periodically broadcasts advanced analytics stats via WebSocket.\n\n    Args:\n        interval_seconds: Broadcast interval in seconds (default: 10).\n            Higher than dashboard stats due to query complexity.\n    \"\"\"\n    global _broadcast_running\n    _broadcast_running = True\n\n    logger.info(\"Starting advanced analytics broadcast loop (interval: %ds)\", interval_seconds)\n\n    from app.core.websocket import manager\n\n    while _broadcast_running:\n        try:\n            factory = get_session_factory()\n\n            # P1 Fix: Use a dedicated session for SettingsService to ensure stability\n            async with factory() as session:\n                settings_service = SettingsService(db=session)\n                # Ensure defaults are seeded/loaded if needed\n                # await settings_service.load_cache() # Optional optimization\n\n                service: AnalyticsService = AnalyticsService(session_factory=factory, settings_service=settings_service)\n\n                stats: AdvancedAnalyticsResponse = await service.get_all_advanced_analytics(\n                    ttft_hours=24, step_days=7, cache_hours=24, cost_hours=24, trending_limit=10\n                )\n\n                await manager.emit_advanced_analytics_stats(stats.model_dump(mode=\"json\"))\n\n        except Exception as e:\n            logger.error(\"Error in analytics broadcast: %s\", e, exc_info=True)\n\n        await asyncio.sleep(interval_seconds)\n\n    logger.info(\"Advanced analytics broadcast loop stopped\")\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_advanced_analytics","title":"<code>get_advanced_analytics(service, current_user, assistant_id=Query(None, description='Filter by assistant ID'), ttft_hours=Query(24, ge=1, le=168, description='TTFT analysis period in hours'), step_days=Query(7, ge=1, le=90, description='Step breakdown period in days'), cache_hours=Query(24, ge=1, le=168, description='Cache metrics period in hours'), cost_hours=Query(24, ge=1, le=168, description='Cost analysis period in hours'), trending_limit=Query(10, ge=1, le=50, description='Number of trending topics'))</code>  <code>async</code>","text":"<p>Get comprehensive advanced analytics for the admin dashboard.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[AnalyticsService, Depends(get_analytics_service)]</code>)           \u2013            <p>The analytics service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The authenticated admin user.</p> </li> <li> <code>assistant_id</code>               (<code>Optional[UUID]</code>, default:                   <code>Query(None, description='Filter by assistant ID')</code> )           \u2013            <p>Optional filter by assistant ID.</p> </li> <li> <code>ttft_hours</code>               (<code>int</code>, default:                   <code>Query(24, ge=1, le=168, description='TTFT analysis period in hours')</code> )           \u2013            <p>TTFT analysis period in hours.</p> </li> <li> <code>step_days</code>               (<code>int</code>, default:                   <code>Query(7, ge=1, le=90, description='Step breakdown period in days')</code> )           \u2013            <p>Step breakdown period in days.</p> </li> <li> <code>cache_hours</code>               (<code>int</code>, default:                   <code>Query(24, ge=1, le=168, description='Cache metrics period in hours')</code> )           \u2013            <p>Cache metrics period in hours.</p> </li> <li> <code>cost_hours</code>               (<code>int</code>, default:                   <code>Query(24, ge=1, le=168, description='Cost analysis period in hours')</code> )           \u2013            <p>Cost analysis period in hours.</p> </li> <li> <code>trending_limit</code>               (<code>int</code>, default:                   <code>Query(10, ge=1, le=50, description='Number of trending topics')</code> )           \u2013            <p>Number of trending topics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AdvancedAnalyticsResponse</code> (              <code>AdvancedAnalyticsResponse</code> )          \u2013            <p>A comprehensive analytics response including TTFT percentiles, pipeline step breakdown, cache hit rate, trending topics, topic diversity score, assistant token costs, and document freshness.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/advanced\", response_model=AdvancedAnalyticsResponse)\nasync def get_advanced_analytics(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n    assistant_id: Optional[UUID] = Query(None, description=\"Filter by assistant ID\"),\n    ttft_hours: int = Query(24, ge=1, le=168, description=\"TTFT analysis period in hours\"),\n    step_days: int = Query(7, ge=1, le=90, description=\"Step breakdown period in days\"),\n    cache_hours: int = Query(24, ge=1, le=168, description=\"Cache metrics period in hours\"),\n    cost_hours: int = Query(24, ge=1, le=168, description=\"Cost analysis period in hours\"),\n    trending_limit: int = Query(10, ge=1, le=50, description=\"Number of trending topics\"),\n) -&gt; AdvancedAnalyticsResponse:\n    \"\"\"\n    Get comprehensive advanced analytics for the admin dashboard.\n\n    Args:\n        service: The analytics service instance.\n        current_user: The authenticated admin user.\n        assistant_id: Optional filter by assistant ID.\n        ttft_hours: TTFT analysis period in hours.\n        step_days: Step breakdown period in days.\n        cache_hours: Cache metrics period in hours.\n        cost_hours: Cost analysis period in hours.\n        trending_limit: Number of trending topics.\n\n    Returns:\n        AdvancedAnalyticsResponse: A comprehensive analytics response including\n            TTFT percentiles, pipeline step breakdown, cache hit rate, trending topics,\n            topic diversity score, assistant token costs, and document freshness.\n    \"\"\"\n    return await service.get_all_advanced_analytics(\n        ttft_hours=ttft_hours,\n        step_days=step_days,\n        cache_hours=cache_hours,\n        cost_hours=cost_hours,\n        trending_limit=trending_limit,\n        assistant_id=assistant_id,\n    )\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_assistant_costs","title":"<code>get_assistant_costs(service, current_user, hours=Query(24, ge=1, le=168, description='Analysis period in hours'))</code>  <code>async</code>","text":"<p>Get token costs by assistant.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[AnalyticsService, Depends(get_analytics_service)]</code>)           \u2013            <p>The analytics service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The authenticated admin user.</p> </li> <li> <code>hours</code>               (<code>int</code>, default:                   <code>Query(24, ge=1, le=168, description='Analysis period in hours')</code> )           \u2013            <p>Analysis period in hours.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[AssistantCost]</code>           \u2013            <p>list[AssistantCost]: A list of costs per assistant.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/costs\", response_model=List[AssistantCost])\nasync def get_assistant_costs(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n    hours: int = Query(24, ge=1, le=168, description=\"Analysis period in hours\"),\n) -&gt; List[AssistantCost]:\n    \"\"\"\n    Get token costs by assistant.\n\n    Args:\n        service: The analytics service instance.\n        current_user: The authenticated admin user.\n        hours: Analysis period in hours.\n\n    Returns:\n        list[AssistantCost]: A list of costs per assistant.\n    \"\"\"\n    return await service.get_assistant_costs(hours)\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_document_freshness","title":"<code>get_document_freshness(service, current_user)</code>  <code>async</code>","text":"<p>Get knowledge base document freshness distribution.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[AnalyticsService, Depends(get_analytics_service)]</code>)           \u2013            <p>The analytics service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[DocumentFreshness]</code>           \u2013            <p>list[DocumentFreshness]: A list representing document freshness distribution.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/freshness\", response_model=List[DocumentFreshness])\nasync def get_document_freshness(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; List[DocumentFreshness]:\n    \"\"\"\n    Get knowledge base document freshness distribution.\n\n    Args:\n        service: The analytics service instance.\n        current_user: The authenticated admin user.\n\n    Returns:\n        list[DocumentFreshness]: A list representing document freshness distribution.\n    \"\"\"\n    return await service.get_document_freshness()\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_trending_topics","title":"<code>get_trending_topics(service, current_user, assistant_id=Query(None, description='Filter by assistant ID'), limit=Query(10, ge=1, le=50, description='Number of topics to return'))</code>  <code>async</code>","text":"<p>Get top trending questions/topics.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[AnalyticsService, Depends(get_analytics_service)]</code>)           \u2013            <p>The analytics service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The authenticated admin user.</p> </li> <li> <code>assistant_id</code>               (<code>Optional[UUID]</code>, default:                   <code>Query(None, description='Filter by assistant ID')</code> )           \u2013            <p>Optional filter by assistant ID.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>Query(10, ge=1, le=50, description='Number of topics to return')</code> )           \u2013            <p>Number of topics to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[TrendingTopic]</code>           \u2013            <p>list[TrendingTopic]: A list of trending topics.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/trending\", response_model=List[TrendingTopic])\nasync def get_trending_topics(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n    assistant_id: Optional[UUID] = Query(None, description=\"Filter by assistant ID\"),\n    limit: int = Query(10, ge=1, le=50, description=\"Number of topics to return\"),\n) -&gt; List[TrendingTopic]:\n    \"\"\"\n    Get top trending questions/topics.\n\n    Args:\n        service: The analytics service instance.\n        current_user: The authenticated admin user.\n        assistant_id: Optional filter by assistant ID.\n        limit: Number of topics to return.\n\n    Returns:\n        list[TrendingTopic]: A list of trending topics.\n    \"\"\"\n    return await service.get_trending_topics(assistant_id, limit)\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.get_ttft_percentiles","title":"<code>get_ttft_percentiles(service, current_user, hours=Query(24, ge=1, le=168, description='Analysis period in hours'))</code>  <code>async</code>","text":"<p>Get Time-to-First-Token percentiles.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[AnalyticsService, Depends(get_analytics_service)]</code>)           \u2013            <p>The analytics service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The authenticated admin user.</p> </li> <li> <code>hours</code>               (<code>int</code>, default:                   <code>Query(24, ge=1, le=168, description='Analysis period in hours')</code> )           \u2013            <p>Analysis period in hours.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TTFTPercentiles</code> (              <code>TTFTPercentiles</code> )          \u2013            <p>The calculated TTFT percentiles (p50, p95, p99).</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>@router.get(\"/ttft\", response_model=TTFTPercentiles)\nasync def get_ttft_percentiles(\n    service: Annotated[AnalyticsService, Depends(get_analytics_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n    hours: int = Query(24, ge=1, le=168, description=\"Analysis period in hours\"),\n) -&gt; TTFTPercentiles:\n    \"\"\"\n    Get Time-to-First-Token percentiles.\n\n    Args:\n        service: The analytics service instance.\n        current_user: The authenticated admin user.\n        hours: Analysis period in hours.\n\n    Returns:\n        TTFTPercentiles: The calculated TTFT percentiles (p50, p95, p99).\n    \"\"\"\n    result: Optional[TTFTPercentiles] = await service.get_ttft_percentiles(hours)\n\n    if not result:\n        return TTFTPercentiles(p50=0.0, p95=0.0, p99=0.0, period_hours=hours)\n\n    return result\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.start_broadcast_task","title":"<code>start_broadcast_task(interval_seconds=10)</code>  <code>async</code>","text":"<p>Start the periodic broadcast background task.</p> <p>Parameters:</p> <ul> <li> <code>interval_seconds</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Broadcast interval in seconds.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>async def start_broadcast_task(interval_seconds: int = 10) -&gt; None:\n    \"\"\"\n    Start the periodic broadcast background task.\n\n    Args:\n        interval_seconds: Broadcast interval in seconds.\n    \"\"\"\n    global _broadcast_task, _broadcast_running\n\n    if _broadcast_task is not None and not _broadcast_task.done():\n        logger.warning(\"Analytics broadcast task already running\")\n        return\n\n    _broadcast_running = True\n    _broadcast_task = asyncio.create_task(broadcast_analytics_loop(interval_seconds))\n    logger.info(\"Analytics broadcast task started\")\n</code></pre>"},{"location":"api/v1/analytics/#app.api.v1.endpoints.analytics.stop_broadcast_task","title":"<code>stop_broadcast_task()</code>  <code>async</code>","text":"<p>Stop the periodic broadcast background task.</p> Source code in <code>app/api/v1/endpoints/analytics.py</code> <pre><code>async def stop_broadcast_task() -&gt; None:\n    \"\"\"\n    Stop the periodic broadcast background task.\n    \"\"\"\n    global _broadcast_task, _broadcast_running\n\n    if _broadcast_task is None:\n        return\n\n    _broadcast_running = False\n\n    try:\n        await asyncio.wait_for(_broadcast_task, timeout=10.0)\n    except asyncio.TimeoutError:\n        logger.warning(\"Analytics broadcast task did not stop gracefully, cancelling\")\n        _broadcast_task.cancel()\n    except Exception as e:\n        logger.error(\"Error during stop_broadcast_task: %s\", e)\n\n    _broadcast_task = None\n    logger.info(\"Analytics broadcast task stopped\")\n</code></pre>"},{"location":"api/v1/assistants/","title":"Assistants","text":""},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.clear_assistant_cache","title":"<code>clear_assistant_cache(assistant_id, service, current_user)</code>  <code>async</code>","text":"<p>Manually purge the semantic cache for a specific assistant (Admin only).</p> <p>Useful when documents are updated or LLM instructions change to ensure fresh data.</p> <p>Parameters:</p> <ul> <li> <code>assistant_id</code>               (<code>UUID</code>)           \u2013            <p>The unique identifier of the assistant.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>The assistant service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The current authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, int]</code>           \u2013            <p>A dictionary containing the number of deleted cache entries.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FunctionalError</code>             \u2013            <p>If there is a functional error clearing the cache.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If clearing the cache fails due to an unexpected issue.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.delete(\"/{assistant_id}/cache\", response_model=Dict[str, int])\nasync def clear_assistant_cache(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; Dict[str, int]:\n    \"\"\"\n    Manually purge the semantic cache for a specific assistant (Admin only).\n\n    Useful when documents are updated or LLM instructions change to ensure fresh data.\n\n    Args:\n        assistant_id: The unique identifier of the assistant.\n        service: The assistant service instance.\n        current_user: The current authenticated admin user.\n\n    Returns:\n        A dictionary containing the number of deleted cache entries.\n\n    Raises:\n        FunctionalError: If there is a functional error clearing the cache.\n        TechnicalError: If clearing the cache fails due to an unexpected issue.\n    \"\"\"\n    try:\n        count: int = await service.clear_cache(assistant_id)\n        return {\"deleted_count\": count}\n    except Exception as e:\n        logger.error(f\"Failed to clear cache for assistant {assistant_id}: {e}\", exc_info=True)\n        if isinstance(e, (FunctionalError, TechnicalError)):\n            raise\n        raise TechnicalError(f\"Failed to clear cache: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.create_assistant","title":"<code>create_assistant(assistant, service, current_user)</code>  <code>async</code>","text":"<p>Create a new assistant (Admin only).</p> <p>Allows an authenticated administrator to create a new assistant.</p> <p>Parameters:</p> <ul> <li> <code>assistant</code>               (<code>AssistantCreate</code>)           \u2013            <p>The assistant creation data.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>The assistant service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The current authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AssistantResponse</code>           \u2013            <p>The created assistant response object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FunctionalError</code>             \u2013            <p>If there is a validation or functional error during assistant creation.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If creating the assistant fails due to an unexpected issue.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.post(\"/\", response_model=AssistantResponse, status_code=status.HTTP_201_CREATED)\nasync def create_assistant(\n    assistant: AssistantCreate,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; AssistantResponse:\n    \"\"\"\n    Create a new assistant (Admin only).\n\n    Allows an authenticated administrator to create a new assistant.\n\n    Args:\n        assistant: The assistant creation data.\n        service: The assistant service instance.\n        current_user: The current authenticated admin user.\n\n    Returns:\n        The created assistant response object.\n\n    Raises:\n        FunctionalError: If there is a validation or functional error during assistant creation.\n        TechnicalError: If creating the assistant fails due to an unexpected issue.\n    \"\"\"\n    try:\n        return await service.create_assistant(assistant)\n    except Exception as e:\n        logger.error(f\"Failed to create assistant: {e}\", exc_info=True)\n        if isinstance(e, (FunctionalError, TechnicalError)):\n            raise\n        raise TechnicalError(f\"Failed to create assistant: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.delete_assistant","title":"<code>delete_assistant(assistant_id, service, current_user)</code>  <code>async</code>","text":"<p>Delete an assistant (Admin only).</p> <p>Allows an authenticated administrator to delete an existing assistant identified by its ID.</p> <p>Parameters:</p> <ul> <li> <code>assistant_id</code>               (<code>UUID</code>)           \u2013            <p>The unique identifier of the assistant to delete.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>The assistant service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The current authenticated admin user.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EntityNotFound</code>             \u2013            <p>If the assistant with the given ID does not exist.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If deleting the assistant fails due to an unexpected issue.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.delete(\"/{assistant_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_assistant(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; None:\n    \"\"\"\n    Delete an assistant (Admin only).\n\n    Allows an authenticated administrator to delete an existing assistant identified by its ID.\n\n    Args:\n        assistant_id: The unique identifier of the assistant to delete.\n        service: The assistant service instance.\n        current_user: The current authenticated admin user.\n\n    Raises:\n        EntityNotFound: If the assistant with the given ID does not exist.\n        TechnicalError: If deleting the assistant fails due to an unexpected issue.\n    \"\"\"\n    try:\n        success: bool = await service.delete_assistant(assistant_id)\n        if not success:\n            raise EntityNotFound(\"Assistant not found\")\n        return  # 204 No Content\n    except EntityNotFound:\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to delete assistant {assistant_id}: {e}\", exc_info=True)\n        raise TechnicalError(f\"Failed to delete assistant: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.delete_assistant_avatar","title":"<code>delete_assistant_avatar(assistant_id, service, current_user)</code>  <code>async</code>","text":"<p>Remove the avatar image from the assistant.</p> <p>Allows an authenticated administrator to remove the avatar image associated with an assistant.</p> <p>Parameters:</p> <ul> <li> <code>assistant_id</code>               (<code>UUID</code>)           \u2013            <p>The unique identifier of the assistant.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>The assistant service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The current authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AssistantResponse</code>           \u2013            <p>The updated assistant response object with the avatar removed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FunctionalError</code>             \u2013            <p>If there is a functional error removing the avatar.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If removing the avatar fails due to an unexpected issue.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.delete(\"/{assistant_id}/avatar\", response_model=AssistantResponse)\nasync def delete_assistant_avatar(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; AssistantResponse:\n    \"\"\"\n    Remove the avatar image from the assistant.\n\n    Allows an authenticated administrator to remove the avatar image associated with an assistant.\n\n    Args:\n        assistant_id: The unique identifier of the assistant.\n        service: The assistant service instance.\n        current_user: The current authenticated admin user.\n\n    Returns:\n        The updated assistant response object with the avatar removed.\n\n    Raises:\n        FunctionalError: If there is a functional error removing the avatar.\n        TechnicalError: If removing the avatar fails due to an unexpected issue.\n    \"\"\"\n    try:\n        return await service.remove_avatar(assistant_id)\n    except Exception as e:\n        logger.error(f\"Failed to remove avatar: {e}\", exc_info=True)\n        if isinstance(e, (FunctionalError, TechnicalError)):\n            raise\n        raise TechnicalError(f\"Failed to remove avatar: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.get_assistant","title":"<code>get_assistant(assistant_id, service, user)</code>  <code>async</code>","text":"<p>Get a single assistant by ID.</p> <p>Retrieves an assistant's details. Access control checks are applied: if an assistant requires user authentication, an unauthenticated user will receive a 401 Unauthorized error.</p> <p>Parameters:</p> <ul> <li> <code>assistant_id</code>               (<code>UUID</code>)           \u2013            <p>The unique identifier of the assistant.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>The assistant service instance.</p> </li> <li> <code>user</code>               (<code>Annotated[Optional[User], Depends(get_current_user_optional)]</code>)           \u2013            <p>The current optional user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AssistantResponse</code>           \u2013            <p>The assistant response object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EntityNotFound</code>             \u2013            <p>If the assistant with the given ID does not exist.</p> </li> <li> <code>HTTPException</code>             \u2013            <p>If authentication is required but the user is not logged in (401 Unauthorized).</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If fetching the assistant fails due to an unexpected issue.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.get(\"/{assistant_id}\", response_model=AssistantResponse)\nasync def get_assistant(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    user: Annotated[Optional[User], Depends(get_current_user_optional)],\n) -&gt; AssistantResponse:\n    \"\"\"\n    Get a single assistant by ID.\n\n    Retrieves an assistant's details. Access control checks are applied:\n    if an assistant requires user authentication, an unauthenticated user will\n    receive a 401 Unauthorized error.\n\n    Args:\n        assistant_id: The unique identifier of the assistant.\n        service: The assistant service instance.\n        user: The current optional user.\n\n    Returns:\n        The assistant response object.\n\n    Raises:\n        EntityNotFound: If the assistant with the given ID does not exist.\n        HTTPException: If authentication is required but the user is not logged in (401 Unauthorized).\n        TechnicalError: If fetching the assistant fails due to an unexpected issue.\n    \"\"\"\n    try:\n        assistant: Optional[AssistantResponse] = await service.get_assistant(assistant_id)\n        if not assistant:\n            raise EntityNotFound(\"Assistant not found\")\n\n        # Access Control: If assistant requires authentication, user must be logged in.\n        if assistant.user_authentication and not user:\n            logger.warning(f\"Access denied for assistant {assistant_id}: User Authentication Required\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Authentication required for this assistant\",\n            )\n\n        return assistant\n\n    except (EntityNotFound, HTTPException):\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to fetch assistant {assistant_id}: {e}\", exc_info=True)\n        raise TechnicalError(f\"Failed to fetch assistant: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.get_assistant_avatar","title":"<code>get_assistant_avatar(assistant_id, service, user)</code>  <code>async</code>","text":"<p>Get the avatar image file.</p> <p>Retrieves the avatar image file for a specific assistant. Access control is applied: if the assistant requires authentication, unauthenticated users will receive a 404 Not Found error (for obfuscation).</p> <p>Parameters:</p> <ul> <li> <code>assistant_id</code>               (<code>UUID</code>)           \u2013            <p>The unique identifier of the assistant.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>The assistant service instance.</p> </li> <li> <code>user</code>               (<code>Annotated[Optional[User], Depends(get_current_user_optional)]</code>)           \u2013            <p>The current optional user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FileResponse</code>           \u2013            <p>The avatar image file response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>If the avatar or assistant is not found (404), or            if authentication is required but the user is not logged in (404 for obfuscation).</p> </li> <li> <code>EntityNotFound</code>             \u2013            <p>If the assistant or avatar is genuinely not found.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If fetching the avatar fails due to an unexpected issue.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.get(\"/{assistant_id}/avatar\")\nasync def get_assistant_avatar(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    user: Annotated[Optional[User], Depends(get_current_user_optional)],\n) -&gt; FileResponse:\n    \"\"\"\n    Get the avatar image file.\n\n    Retrieves the avatar image file for a specific assistant.\n    Access control is applied: if the assistant requires authentication,\n    unauthenticated users will receive a 404 Not Found error (for obfuscation).\n\n    Args:\n        assistant_id: The unique identifier of the assistant.\n        service: The assistant service instance.\n        user: The current optional user.\n\n    Returns:\n        The avatar image file response.\n\n    Raises:\n        HTTPException: If the avatar or assistant is not found (404), or\n                       if authentication is required but the user is not logged in (404 for obfuscation).\n        EntityNotFound: If the assistant or avatar is genuinely not found.\n        TechnicalError: If fetching the avatar fails due to an unexpected issue.\n    \"\"\"\n    try:\n        # Check Access Control before serving file\n        assistant: Optional[AssistantResponse] = await service.get_assistant(assistant_id)\n        if not assistant:\n            raise EntityNotFound(\"Avatar not found\")  # Obfuscate assistant not found as avatar not found\n\n        if assistant.user_authentication and not user:\n            # Private assistant -&gt; Private avatar, obfuscate existence for unauthorized users\n            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Avatar not found\")\n\n        file_path: Optional[str] = await service.get_avatar_path(assistant_id)\n        if not file_path:\n            raise EntityNotFound(\"Avatar not found\")\n\n        return FileResponse(file_path)\n    except EntityNotFound:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Avatar not found\")\n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to get avatar: {e}\", exc_info=True)\n        raise TechnicalError(f\"Failed to get avatar: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.get_assistants","title":"<code>get_assistants(service, user, skip=Query(0, ge=0), limit=Query(100, ge=1, le=1000))</code>  <code>async</code>","text":"<p>List all assistants.</p> <p>Public access allowed but filtered for guests. Private assistants are excluded if no user is authenticated.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>The assistant service instance.</p> </li> <li> <code>user</code>               (<code>Annotated[Optional[User], Depends(get_current_user_optional)]</code>)           \u2013            <p>The current optional user. If None, guests are assumed.</p> </li> <li> <code>skip</code>               (<code>int</code>, default:                   <code>Query(0, ge=0)</code> )           \u2013            <p>The number of records to skip for pagination.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>Query(100, ge=1, le=1000)</code> )           \u2013            <p>The maximum number of records to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[AssistantResponse]</code>           \u2013            <p>A list of assistant response objects.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TechnicalError</code>             \u2013            <p>If fetching assistants fails due to an unexpected issue.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.get(\"/\", response_model=List[AssistantResponse])\nasync def get_assistants(\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    user: Annotated[Optional[User], Depends(get_current_user_optional)],\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n) -&gt; List[AssistantResponse]:\n    \"\"\"\n    List all assistants.\n\n    Public access allowed but filtered for guests. Private assistants are excluded\n    if no user is authenticated.\n\n    Args:\n        service: The assistant service instance.\n        user: The current optional user. If None, guests are assumed.\n        skip: The number of records to skip for pagination.\n        limit: The maximum number of records to return.\n\n    Returns:\n        A list of assistant response objects.\n\n    Raises:\n        TechnicalError: If fetching assistants fails due to an unexpected issue.\n    \"\"\"\n    # Filter: If User is missing (Guest), exclude private assistants.\n    exclude_private: bool = user is None\n\n    try:\n        # TODO: Refactor Service to support DB-side pagination (P1)\n        # Passing exclude_private to service layer\n        assistants: List[AssistantResponse] = await service.get_assistants(exclude_private=exclude_private)\n\n        # Manual Slicing (Temporary P2 solution)\n        return assistants[skip : skip + limit]\n\n    except Exception as e:\n        logger.error(f\"Failed to fetch assistants: {e}\", exc_info=True)\n        raise TechnicalError(f\"Failed to fetch assistants: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.update_assistant","title":"<code>update_assistant(assistant_id, assistant, service, current_user)</code>  <code>async</code>","text":"<p>Update an existing assistant (Admin only).</p> <p>Allows an authenticated administrator to update an existing assistant identified by its ID.</p> <p>Parameters:</p> <ul> <li> <code>assistant_id</code>               (<code>UUID</code>)           \u2013            <p>The unique identifier of the assistant to update.</p> </li> <li> <code>assistant</code>               (<code>AssistantUpdate</code>)           \u2013            <p>The assistant update data.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>The assistant service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The current authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AssistantResponse</code>           \u2013            <p>The updated assistant response object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EntityNotFound</code>             \u2013            <p>If the assistant with the given ID does not exist.</p> </li> <li> <code>FunctionalError</code>             \u2013            <p>If there is a validation or functional error during the update.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If updating the assistant fails due to an unexpected issue.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.put(\"/{assistant_id}\", response_model=AssistantResponse)\nasync def update_assistant(\n    assistant_id: UUID,\n    assistant: AssistantUpdate,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; AssistantResponse:\n    \"\"\"\n    Update an existing assistant (Admin only).\n\n    Allows an authenticated administrator to update an existing assistant identified by its ID.\n\n    Args:\n        assistant_id: The unique identifier of the assistant to update.\n        assistant: The assistant update data.\n        service: The assistant service instance.\n        current_user: The current authenticated admin user.\n\n    Returns:\n        The updated assistant response object.\n\n    Raises:\n        EntityNotFound: If the assistant with the given ID does not exist.\n        FunctionalError: If there is a validation or functional error during the update.\n        TechnicalError: If updating the assistant fails due to an unexpected issue.\n    \"\"\"\n    try:\n        updated_assistant: Optional[AssistantResponse] = await service.update_assistant(assistant_id, assistant)\n        if not updated_assistant:\n            raise EntityNotFound(\"Assistant not found\")\n        return updated_assistant\n    except (EntityNotFound, FunctionalError, TechnicalError):\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to update assistant {assistant_id}: {e}\", exc_info=True)\n        raise TechnicalError(f\"Failed to update assistant: {e}\")\n</code></pre>"},{"location":"api/v1/assistants/#app.api.v1.endpoints.assistants.upload_assistant_avatar","title":"<code>upload_assistant_avatar(assistant_id, service, current_user, file=File(...))</code>  <code>async</code>","text":"<p>Upload an avatar image for the assistant.</p> <p>Allows an authenticated administrator to upload an avatar image for a specific assistant. The service layer handles file processing and ensures assistant existence.</p> <p>Parameters:</p> <ul> <li> <code>assistant_id</code>               (<code>UUID</code>)           \u2013            <p>The unique identifier of the assistant.</p> </li> <li> <code>service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>The assistant service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The current authenticated admin user.</p> </li> <li> <code>file</code>               (<code>UploadFile</code>, default:                   <code>File(...)</code> )           \u2013            <p>The image file to upload.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AssistantResponse</code>           \u2013            <p>The updated assistant response object with the new avatar.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FunctionalError</code>             \u2013            <p>If the uploaded file is invalid or not an image.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If uploading the avatar fails due to an unexpected issue.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/assistants.py</code> <pre><code>@router.post(\"/{assistant_id}/avatar\", response_model=AssistantResponse)\nasync def upload_assistant_avatar(\n    assistant_id: UUID,\n    service: Annotated[AssistantService, Depends(get_assistant_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n    file: UploadFile = File(...),\n) -&gt; AssistantResponse:\n    \"\"\"\n    Upload an avatar image for the assistant.\n\n    Allows an authenticated administrator to upload an avatar image for a specific assistant.\n    The service layer handles file processing and ensures assistant existence.\n\n    Args:\n        assistant_id: The unique identifier of the assistant.\n        service: The assistant service instance.\n        current_user: The current authenticated admin user.\n        file: The image file to upload.\n\n    Returns:\n        The updated assistant response object with the new avatar.\n\n    Raises:\n        FunctionalError: If the uploaded file is invalid or not an image.\n        TechnicalError: If uploading the avatar fails due to an unexpected issue.\n    \"\"\"\n    try:\n        # The service layer implicitly checks for assistant existence and handles file processing.\n        return await service.upload_avatar(assistant_id, file)\n    except Exception as e:\n        logger.error(f\"Failed to upload avatar: {e}\", exc_info=True)\n        if isinstance(e, (FunctionalError, TechnicalError)):\n            raise\n        raise TechnicalError(f\"Failed to upload avatar: {e}\")\n</code></pre>"},{"location":"api/v1/audio/","title":"Audio","text":"<p>This module provides API endpoints for streaming audio files.</p>"},{"location":"api/v1/audio/#app.api.v1.endpoints.audio.stream_audio","title":"<code>stream_audio(document_id, request, file_service, user)</code>  <code>async</code>","text":"<p>Streams an audio file from the server.</p> <p>This endpoint retrieves file information for a given document ID and returns a FileResponse to stream the audio file. It delegates Range handling to Starlette's FileResponse implementation.</p> <p>Parameters:</p> <ul> <li> <code>document_id</code>               (<code>UUID</code>)           \u2013            <p>The unique identifier of the audio document to stream.</p> </li> <li> <code>request</code>               (<code>Request</code>)           \u2013            <p>The FastAPI Request object.</p> </li> <li> <code>file_service</code>               (<code>Annotated[FileService, Depends(get_file_service)]</code>)           \u2013            <p>The file service for handling file operations.</p> </li> <li> <code>user</code>               (<code>Annotated[Optional[User], Depends(get_optional_user)]</code>)           \u2013            <p>The optionally authenticated user making the request.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FileResponse</code> (              <code>FileResponse</code> )          \u2013            <p>A response object that streams the requested audio file.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EntityNotFound</code>             \u2013            <p>If the document or its associated connector is not found.</p> </li> <li> <code>FunctionalError</code>             \u2013            <p>If there is a functional issue with the request.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If an unexpected error occurs during streaming.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/audio.py</code> <pre><code>@router.get(\"/stream/{document_id}\")\nasync def stream_audio(\n    document_id: UUID,\n    request: Request,\n    file_service: Annotated[FileService, Depends(get_file_service)],\n    user: Annotated[Optional[User], Depends(get_optional_user)],\n) -&gt; FileResponse:\n    \"\"\"\n    Streams an audio file from the server.\n\n    This endpoint retrieves file information for a given document ID and returns\n    a FileResponse to stream the audio file. It delegates Range handling to\n    Starlette's FileResponse implementation.\n\n    Args:\n        document_id: The unique identifier of the audio document to stream.\n        request: The FastAPI Request object.\n        file_service: The file service for handling file operations.\n        user: The optionally authenticated user making the request.\n\n    Returns:\n        FileResponse: A response object that streams the requested audio file.\n\n    Raises:\n        EntityNotFound: If the document or its associated connector is not found.\n        FunctionalError: If there is a functional issue with the request.\n        TechnicalError: If an unexpected error occurs during streaming.\n    \"\"\"\n    try:\n        # P2: Strict Typing with Pydantic model\n        stream_info: FileStreamingInfo = await file_service.get_file_for_streaming(document_id, current_user=user)\n\n        # Access log audit could go here if needed\n        # if user: logger.debug(f\"Streaming {document_id} for {user.email}\")\n\n        return FileResponse(\n            path=stream_info.file_path,\n            media_type=stream_info.media_type,\n            filename=stream_info.file_name,\n            content_disposition_type=\"inline\",\n        )\n\n    except (EntityNotFound, FunctionalError):\n        # Already logged or handled at service level if needed\n        raise\n    except Exception as e:\n        logger.error(f\"Audio stream failed for {document_id}: {str(e)}\", exc_info=True)\n        raise TechnicalError(f\"Audio stream failed: {str(e)}\")\n</code></pre>"},{"location":"api/v1/auth/","title":"Auth","text":""},{"location":"api/v1/auth/#app.api.v1.endpoints.auth.login_access_token","title":"<code>login_access_token(form_data, auth_service)</code>  <code>async</code>","text":"<p>OAuth2 compatible token login, get an access token for future requests.</p> <p>Security: - Uses strict OAuth2 form (username/password). - Rate Limiting should be applied at Gateway/Nginx level or via Middleware.</p> <p>Parameters:</p> <ul> <li> <code>form_data</code>               (<code>Annotated[OAuth2PasswordRequestForm, Depends()]</code>)           \u2013            <p>OAuth2 password request form containing username and password.</p> </li> <li> <code>auth_service</code>               (<code>Annotated[AuthService, Depends(get_auth_service)]</code>)           \u2013            <p>Injected authentication service.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Token</code> (              <code>Token</code> )          \u2013            <p>A Token object containing the access token and token type.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FunctionalError</code>             \u2013            <p>If authentication fails due to invalid credentials or inactive user.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If an unexpected error occurs during authentication.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/auth.py</code> <pre><code>@router.post(\"/login\", response_model=Token)\nasync def login_access_token(\n    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],\n    auth_service: Annotated[AuthService, Depends(get_auth_service)],\n) -&gt; Token:\n    \"\"\"\n    OAuth2 compatible token login, get an access token for future requests.\n\n    Security:\n    - Uses strict OAuth2 form (username/password).\n    - Rate Limiting should be applied at Gateway/Nginx level or via Middleware.\n\n    Args:\n        form_data: OAuth2 password request form containing username and password.\n        auth_service: Injected authentication service.\n\n    Returns:\n        Token: A Token object containing the access token and token type.\n\n    Raises:\n        FunctionalError: If authentication fails due to invalid credentials or inactive user.\n        TechnicalError: If an unexpected error occurs during authentication.\n    \"\"\"\n    try:\n        return await auth_service.authenticate(form_data.username, form_data.password)\n\n    except (FunctionalError, TechnicalError):\n        # Re-raise known exceptions to be handled by global exception handlers\n        raise\n    except Exception as e:\n        logger.error(f\"Login failed unexpectedly: {e}\", exc_info=True)\n        raise TechnicalError(\"Login failed\")\n</code></pre>"},{"location":"api/v1/chat/","title":"Chat","text":""},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.chat_stream","title":"<code>chat_stream(request, chat_service, assistant_service, user)</code>  <code>async</code>","text":"<p>Stream chat response for a session.</p> <p>Supports SSE (Server-Sent Events) via NDJSON or text/event-stream.</p> <p>Parameters:</p> <ul> <li> <code>request</code>               (<code>ChatRequest</code>)           \u2013            <p>The chat request payload.</p> </li> <li> <code>chat_service</code>               (<code>Annotated[ChatService, Depends(get_chat_service)]</code>)           \u2013            <p>The chat service instance.</p> </li> <li> <code>assistant_service</code>               (<code>Annotated[AssistantService, Depends(get_assistant_service)]</code>)           \u2013            <p>The assistant service instance.</p> </li> <li> <code>user</code>               (<code>Annotated[Optional[User], Depends(get_optional_user)]</code>)           \u2013            <p>The optional authenticated user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>StreamingResponse</code>           \u2013            <p>A StreamingResponse yielding the chat stream.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EntityNotFound</code>             \u2013            <p>If the assistant is not found.</p> </li> <li> <code>HTTPException</code>             \u2013            <p>If authentication is required but user is not authenticated.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If an unexpected error occurs during initialization.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.post(\"/stream\")\nasync def chat_stream(\n    request: ChatRequest,\n    chat_service: Annotated[ChatService, Depends(get_chat_service)],\n    assistant_service: Annotated[AssistantService, Depends(get_assistant_service)],\n    user: Annotated[Optional[User], Depends(get_optional_user)],\n) -&gt; StreamingResponse:\n    \"\"\"\n    Stream chat response for a session.\n\n    Supports SSE (Server-Sent Events) via NDJSON or text/event-stream.\n\n    Args:\n        request: The chat request payload.\n        chat_service: The chat service instance.\n        assistant_service: The assistant service instance.\n        user: The optional authenticated user.\n\n    Returns:\n        A StreamingResponse yielding the chat stream.\n\n    Raises:\n        EntityNotFound: If the assistant is not found.\n        HTTPException: If authentication is required but user is not authenticated.\n        TechnicalError: If an unexpected error occurs during initialization.\n    \"\"\"\n    try:\n        # 1. Fetch Assistant (raw SQLAlchemy model for ChatService)\n        assistant_uuid = request.assistant_id\n        assistant = await assistant_service.get_assistant_model(assistant_uuid)\n        if not assistant:\n            raise EntityNotFound(\"Assistant not found\")\n\n        # 2. Authorization Check\n        user_id = str(user.id) if user else None\n        if assistant.user_authentication and not user_id:\n            logger.warning(f\"Access denied for assistant {assistant.id}: User Authentication Required\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Authentication required for this assistant\",\n            )\n\n        # 3. Stream\n        logger.info(f\"Init Chat Stream | Session: {request.session_id} | User: {user_id}\")\n\n        # Standard RAG Stream (with Vanna routing via SQL connector type)\n        return StreamingResponse(\n            chat_service.stream_chat(\n                request.message,\n                assistant,\n                request.session_id,\n                language=request.language,\n                history=request.history,\n                user_id=user_id,\n            ),\n            media_type=\"application/x-ndjson\",\n        )\n\n    except (FunctionalError, EntityNotFound, HTTPException):\n        raise\n    except Exception as e:\n        logger.error(f\"Chat stream initialization failed: {e}\", exc_info=True)\n        raise TechnicalError(f\"Chat stream initialization failed: {e}\")\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.get_chat_history","title":"<code>get_chat_history(session_id, chat_service, user)</code>  <code>async</code>","text":"<p>Retrieve conversation history for a specific session ID.</p> <p>Parameters:</p> <ul> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>The session ID to retrieve history for.</p> </li> <li> <code>chat_service</code>               (<code>Annotated[ChatService, Depends(get_chat_service)]</code>)           \u2013            <p>The chat service instance.</p> </li> <li> <code>user</code>               (<code>Annotated[Optional[User], Depends(get_optional_user)]</code>)           \u2013            <p>The optional authenticated user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, List[Dict[str, Any]]]</code>           \u2013            <p>A list of formatted chat messages.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.get(\"/{session_id}/history\")\nasync def get_chat_history(\n    session_id: str,\n    chat_service: Annotated[ChatService, Depends(get_chat_service)],\n    user: Annotated[Optional[User], Depends(get_optional_user)],\n) -&gt; Dict[str, List[Dict[str, Any]]]:\n    \"\"\"\n    Retrieve conversation history for a specific session ID.\n\n    Args:\n        session_id: The session ID to retrieve history for.\n        chat_service: The chat service instance.\n        user: The optional authenticated user.\n\n    Returns:\n        A list of formatted chat messages.\n    \"\"\"\n    try:\n        # Get history from the chat repository (Postgres) instead of Redis for full persistence\n        messages = await chat_service.chat_repository.get_messages(session_id)\n\n        # Transform to frontend-compatible format\n        formatted_messages = []\n        for msg in messages:\n            m = {\n                \"id\": str(msg.id),  # Use actual message UUID\n                \"text\": msg.content,\n                \"sender\": \"user\" if msg.role == \"user\" else \"bot\",\n            }\n            # Include metadata (visualization, sources, etc.)\n            if msg.metadata_:\n                meta = msg.metadata_.copy()\n\n                # Format Sources for Frontend (Source[] interface)\n                if \"sources\" in meta and isinstance(meta[\"sources\"], list):\n                    meta[\"sources\"] = [_format_source(s) for s in meta[\"sources\"]]\n\n                # Format Steps (Ensure labels are present)\n                if \"steps\" in meta and isinstance(meta[\"steps\"], list):\n                    meta[\"steps\"] = [_format_step(step) for step in meta[\"steps\"]]\n                    meta[\"steps\"] = _rebuild_step_hierarchy(meta[\"steps\"])\n\n                # Format Visualization (Repair types if stringified by sanitization)\n                if \"visualization\" in meta and meta[\"visualization\"]:\n                    meta[\"visualization\"] = _format_visualization(meta[\"visualization\"])\n\n                m.update(meta)\n\n            formatted_messages.append(m)\n\n        return {\"messages\": formatted_messages}\n    except Exception as e:\n        logger.error(f\"Failed to retrieve history for session {session_id}: {e}\", exc_info=True)\n        if isinstance(e, (TechnicalError, FunctionalError)):\n            raise\n        raise TechnicalError(f\"Failed to retrieve history: {e}\")\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.get_optional_user","title":"<code>get_optional_user(request, db)</code>  <code>async</code>","text":"<p>Resolves user from Bearer token if present, otherwise returns None.</p> <p>Does not raise 401 for invalid tokens, just returns None (for public access if allowed).</p> <p>Parameters:</p> <ul> <li> <code>request</code>               (<code>Request</code>)           \u2013            <p>The FastAPI request object.</p> </li> <li> <code>db</code>               (<code>Annotated[AsyncSession, Depends(get_db)]</code>)           \u2013            <p>The database session.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[User]</code>           \u2013            <p>The User object if found and valid, otherwise None.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>async def get_optional_user(request: Request, db: Annotated[AsyncSession, Depends(get_db)]) -&gt; Optional[User]:\n    \"\"\"\n    Resolves user from Bearer token if present, otherwise returns None.\n\n    Does not raise 401 for invalid tokens, just returns None (for public access if allowed).\n\n    Args:\n        request: The FastAPI request object.\n        db: The database session.\n\n    Returns:\n        The User object if found and valid, otherwise None.\n    \"\"\"\n    auth_header = request.headers.get(\"Authorization\")\n    if auth_header and auth_header.startswith(\"Bearer \"):\n        parts = auth_header.split(\" \")\n        if len(parts) != 2:\n            return None\n        token = parts[1]\n        try:\n            return await get_current_user(token=token, db=db)\n        except Exception:\n            return None\n    return None\n</code></pre>"},{"location":"api/v1/chat/#app.api.v1.endpoints.chat.reset_chat_session","title":"<code>reset_chat_session(session_id, chat_service)</code>  <code>async</code>","text":"<p>Resets the conversation history for a specific session ID.</p> <p>Parameters:</p> <ul> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>The session ID to reset.</p> </li> <li> <code>chat_service</code>               (<code>Annotated[ChatService, Depends(get_chat_service)]</code>)           \u2013            <p>The chat service instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>A success message.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TechnicalError</code>             \u2013            <p>If resetting the conversation fails.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/chat.py</code> <pre><code>@router.delete(\"/{session_id}\")\nasync def reset_chat_session(\n    session_id: str, chat_service: Annotated[ChatService, Depends(get_chat_service)]\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Resets the conversation history for a specific session ID.\n\n    Args:\n        session_id: The session ID to reset.\n        chat_service: The chat service instance.\n\n    Returns:\n        A success message.\n\n    Raises:\n        TechnicalError: If resetting the conversation fails.\n    \"\"\"\n    try:\n        await chat_service.reset_conversation(session_id)\n        return {\"message\": \"Conversation history reset successfully\"}\n    except Exception as e:\n        logger.error(f\"Failed to reset conversation {session_id}: {e}\", exc_info=True)\n        if isinstance(e, (TechnicalError, FunctionalError)):\n            raise\n        raise TechnicalError(f\"Failed to reset conversation: {e}\")\n</code></pre>"},{"location":"api/v1/connectors/","title":"Connectors","text":"<p>Connectors API Endpoints.</p> <p>This module provides the API endpoints for managing connectors and their associated documents. Connectors are used to ingest data from various sources (SQL, files, etc.).</p>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.create_connector","title":"<code>create_connector(connector, service, current_user)</code>  <code>async</code>","text":"<p>Create a new connector.</p> <p>Parameters:</p> <ul> <li> <code>connector</code>               (<code>ConnectorCreate</code>)           \u2013            <p>The connector creation data.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorResponse</code> (              <code>ConnectorResponse</code> )          \u2013            <p>The created connector.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/\", response_model=ConnectorResponse)\nasync def create_connector(\n    connector: ConnectorCreate,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; ConnectorResponse:\n    \"\"\"\n    Create a new connector.\n\n    Args:\n        connector: The connector creation data.\n        service: The connector service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        ConnectorResponse: The created connector.\n    \"\"\"\n    return await service.create_connector(connector)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.create_connector_document","title":"<code>create_connector_document(connector_id, document, service, current_user)</code>  <code>async</code>","text":"<p>Manually add a document to a connector.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector.</p> </li> <li> <code>document</code>               (<code>ConnectorDocumentCreate</code>)           \u2013            <p>The document creation data.</p> </li> <li> <code>service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorDocumentResponse</code> (              <code>ConnectorDocumentResponse</code> )          \u2013            <p>The created document.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/documents\", response_model=ConnectorDocumentResponse)\nasync def create_connector_document(\n    connector_id: UUID,\n    document: ConnectorDocumentCreate,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; ConnectorDocumentResponse:\n    \"\"\"\n    Manually add a document to a connector.\n\n    Args:\n        connector_id: The ID of the connector.\n        document: The document creation data.\n        service: The document service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        ConnectorDocumentResponse: The created document.\n    \"\"\"\n    return await service.create_document(connector_id, document)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.delete_connector","title":"<code>delete_connector(connector_id, service, current_user)</code>  <code>async</code>","text":"<p>Delete a connector and its resources.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector to delete.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>Dict[str, str]: A success message.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.delete(\"/{connector_id}\")\nasync def delete_connector(\n    connector_id: UUID,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Delete a connector and its resources.\n\n    Args:\n        connector_id: The ID of the connector to delete.\n        service: The connector service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        Dict[str, str]: A success message.\n    \"\"\"\n    await service.delete_connector(connector_id)\n    return {\"message\": \"Connector deleted successfully\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.delete_document","title":"<code>delete_document(connector_id, document_id, service, current_user)</code>  <code>async</code>","text":"<p>Delete a specific document.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector.</p> </li> <li> <code>document_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the document to delete.</p> </li> <li> <code>service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>Dict[str, str]: A success message.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.delete(\"/{connector_id}/documents/{document_id}\")\nasync def delete_document(\n    connector_id: UUID,\n    document_id: UUID,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Delete a specific document.\n\n    Args:\n        connector_id: The ID of the connector.\n        document_id: The ID of the document to delete.\n        service: The document service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        Dict[str, str]: A success message.\n    \"\"\"\n    await service.delete_document(document_id)\n    return {\"message\": \"Document deleted successfully\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.get_connector_documents","title":"<code>get_connector_documents(connector_id, service, current_user, page=1, size=20, status=None, search=None)</code>  <code>async</code>","text":"<p>Get paginated documents for a connector.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector.</p> </li> <li> <code>service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> <li> <code>page</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The page number.</p> </li> <li> <code>size</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>The page size.</p> </li> <li> <code>status</code>               (<code>Optional[DocStatus]</code>, default:                   <code>None</code> )           \u2013            <p>Filter by document status.</p> </li> <li> <code>search</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Search term for file name or path.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Dict[str, Any]: Paginated document results.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.get(\"/{connector_id}/documents\", response_model=Dict[str, Any])\nasync def get_connector_documents(\n    connector_id: UUID,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n    page: int = 1,\n    size: int = 20,\n    status: Optional[DocStatus] = None,\n    search: Optional[str] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get paginated documents for a connector.\n\n    Args:\n        connector_id: The ID of the connector.\n        service: The document service instance.\n        current_user: The currently authenticated admin user.\n        page: The page number.\n        size: The page size.\n        status: Filter by document status.\n        search: Search term for file name or path.\n\n    Returns:\n        Dict[str, Any]: Paginated document results.\n    \"\"\"\n    result = await service.get_connector_documents(connector_id, page, size, status, search)\n    # The service already returns ConnectorDocumentResponse objects, but we ensure it here.\n    result[\"items\"] = [ConnectorDocumentResponse.model_validate(doc) for doc in result[\"items\"]]\n    return result\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.get_connectors","title":"<code>get_connectors(service, current_user)</code>  <code>async</code>","text":"<p>List all connectors.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[ConnectorResponse]</code>           \u2013            <p>List[ConnectorResponse]: A list of all connectors.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.get(\"/\", response_model=List[ConnectorResponse])\nasync def get_connectors(\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; List[ConnectorResponse]:\n    \"\"\"\n    List all connectors.\n\n    Args:\n        service: The connector service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        List[ConnectorResponse]: A list of all connectors.\n    \"\"\"\n    return await service.get_connectors()\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.scan_connector_files","title":"<code>scan_connector_files(connector_id, service, current_user)</code>  <code>async</code>","text":"<p>Trigger manual file scan for a folder connector.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector to scan.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorResponse</code> (              <code>ConnectorResponse</code> )          \u2013            <p>The connector being scanned.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/scan-files/\", response_model=ConnectorResponse)\n@router.post(\"/{connector_id}/scan-files\", response_model=ConnectorResponse)\nasync def scan_connector_files(\n    connector_id: UUID,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; ConnectorResponse:\n    \"\"\"\n    Trigger manual file scan for a folder connector.\n\n    Args:\n        connector_id: The ID of the connector to scan.\n        service: The connector service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        ConnectorResponse: The connector being scanned.\n    \"\"\"\n    return await service.scan_connector(connector_id)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.stop_connector","title":"<code>stop_connector(connector_id, service, current_user)</code>  <code>async</code>","text":"<p>Request to stop a running connector sync.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector to stop.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorResponse</code> (              <code>ConnectorResponse</code> )          \u2013            <p>The connector being stopped.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/stop\", response_model=ConnectorResponse)\nasync def stop_connector(\n    connector_id: UUID,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; ConnectorResponse:\n    \"\"\"\n    Request to stop a running connector sync.\n\n    Args:\n        connector_id: The ID of the connector to stop.\n        service: The connector service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        ConnectorResponse: The connector being stopped.\n    \"\"\"\n    return await service.stop_connector(connector_id)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.stop_document","title":"<code>stop_document(connector_id, document_id, service, current_user)</code>  <code>async</code>","text":"<p>Request to stop re-sync for a single document.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector.</p> </li> <li> <code>document_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the document to stop.</p> </li> <li> <code>service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>Dict[str, str]: A success message.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/documents/{document_id}/stop\")\nasync def stop_document(\n    connector_id: UUID,\n    document_id: UUID,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Request to stop re-sync for a single document.\n\n    Args:\n        connector_id: The ID of the connector.\n        document_id: The ID of the document to stop.\n        service: The document service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        Dict[str, str]: A success message.\n    \"\"\"\n    await service.stop_document(document_id)\n    return {\"message\": \"Document sync stop requested\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.sync_connector","title":"<code>sync_connector(connector_id, service, current_user, manager=Depends(get_websocket), force=False)</code>  <code>async</code>","text":"<p>Trigger manual synchronization for a connector.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector to sync.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> <li> <code>force</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to force synchronization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorResponse</code> (              <code>ConnectorResponse</code> )          \u2013            <p>The connector being synced.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/sync\", response_model=ConnectorResponse)\nasync def sync_connector(\n    connector_id: UUID,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n    manager: Websocket = Depends(get_websocket),\n    force: bool = False,\n) -&gt; ConnectorResponse:\n    \"\"\"\n    Trigger manual synchronization for a connector.\n\n    Args:\n        connector_id: The ID of the connector to sync.\n        service: The connector service instance.\n        current_user: The currently authenticated admin user.\n        force: Whether to force synchronization.\n\n    Returns:\n        ConnectorResponse: The connector being synced.\n    \"\"\"\n    connector = await service.trigger_sync(connector_id, force)\n    await manager.emit_trigger_connector_sync(str(connector_id))\n    return connector\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.sync_document","title":"<code>sync_document(connector_id, document_id, service, current_user)</code>  <code>async</code>","text":"<p>Trigger re-sync for a single document.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector.</p> </li> <li> <code>document_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the document to sync.</p> </li> <li> <code>service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>Dict[str, str]: A success message.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/documents/{document_id}/sync\")\nasync def sync_document(\n    connector_id: UUID,\n    document_id: UUID,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Trigger re-sync for a single document.\n\n    Args:\n        connector_id: The ID of the connector.\n        document_id: The ID of the document to sync.\n        service: The document service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        Dict[str, str]: A success message.\n    \"\"\"\n    await service.sync_document(document_id)\n    return {\"message\": \"Document sync queued\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.test_connection","title":"<code>test_connection(payload, service, sql_discovery_service, current_user)</code>  <code>async</code>","text":"<p>Test a connector connection (primarily for SQL).</p> <p>Parameters:</p> <ul> <li> <code>payload</code>               (<code>ConnectorTestConnection</code>)           \u2013            <p>Connection test data.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>sql_discovery_service</code>               (<code>Annotated[Any, Depends(get_sql_discovery_service)]</code>)           \u2013            <p>The SQL discovery service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Dict[str, Any]: A success status and message.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/test-connection\")\nasync def test_connection(\n    payload: ConnectorTestConnection,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    sql_discovery_service: Annotated[Any, Depends(get_sql_discovery_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Test a connector connection (primarily for SQL).\n\n    Args:\n        payload: Connection test data.\n        service: The connector service instance.\n        sql_discovery_service: The SQL discovery service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        Dict[str, Any]: A success status and message.\n    \"\"\"\n    connector_type = payload.connector_type\n    configuration = payload.configuration\n\n    if connector_type in [\"sql\", \"vanna_sql\"]:\n        try:\n            await sql_discovery_service.test_connection(configuration)\n            return {\"success\": True, \"message\": \"Connection successful\"}\n        except Exception as e:\n            logger.error(\"Connection test failed for %s: %s\", connector_type, e)\n            return {\"success\": False, \"message\": str(e)}\n\n    # Add other types if needed\n    return {\"success\": False, \"message\": f\"Connection test not implemented for {connector_type}\"}\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.train_vanna_connector","title":"<code>train_vanna_connector(connector_id, payload, service, document_service, current_user)</code>  <code>async</code>","text":"<p>Train Vanna AI on specific documents (tables/views) for vanna_sql connector.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector.</p> </li> <li> <code>payload</code>               (<code>ConnectorVannaTrain</code>)           \u2013            <p>Training payload containing <code>document_ids</code>.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>document_service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>Dict[str, Any]: A summary of the training results.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.post(\"/{connector_id}/train\")\nasync def train_vanna_connector(\n    connector_id: UUID,\n    payload: ConnectorVannaTrain,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    document_service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Train Vanna AI on specific documents (tables/views) for vanna_sql connector.\n\n    Args:\n        connector_id: The ID of the connector.\n        payload: Training payload containing `document_ids`.\n        service: The connector service instance.\n        document_service: The document service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        Dict[str, Any]: A summary of the training results.\n    \"\"\"\n    return await service.train_vanna(connector_id, payload.document_ids, document_service)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.update_connector","title":"<code>update_connector(connector_id, connector, service, current_user)</code>  <code>async</code>","text":"<p>Update an existing connector.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector to update.</p> </li> <li> <code>connector</code>               (<code>ConnectorUpdate</code>)           \u2013            <p>The connector update data.</p> </li> <li> <code>service</code>               (<code>Annotated[ConnectorService, Depends(get_connector_service)]</code>)           \u2013            <p>The connector service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorResponse</code> (              <code>ConnectorResponse</code> )          \u2013            <p>The updated connector.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.put(\"/{connector_id}\", response_model=ConnectorResponse)\nasync def update_connector(\n    connector_id: UUID,\n    connector: ConnectorUpdate,\n    service: Annotated[ConnectorService, Depends(get_connector_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; ConnectorResponse:\n    \"\"\"\n    Update an existing connector.\n\n    Args:\n        connector_id: The ID of the connector to update.\n        connector: The connector update data.\n        service: The connector service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        ConnectorResponse: The updated connector.\n    \"\"\"\n    return await service.update_connector(connector_id, connector)\n</code></pre>"},{"location":"api/v1/connectors/#app.api.v1.endpoints.connectors.update_document","title":"<code>update_document(connector_id, document_id, document, service, current_user)</code>  <code>async</code>","text":"<p>Update a specific document.</p> <p>Parameters:</p> <ul> <li> <code>connector_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the connector.</p> </li> <li> <code>document_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the document to update.</p> </li> <li> <code>document</code>               (<code>ConnectorDocumentUpdate</code>)           \u2013            <p>The document update data.</p> </li> <li> <code>service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConnectorDocumentResponse</code> (              <code>ConnectorDocumentResponse</code> )          \u2013            <p>The updated document.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/connectors.py</code> <pre><code>@router.put(\"/{connector_id}/documents/{document_id}\", response_model=ConnectorDocumentResponse)\nasync def update_document(\n    connector_id: UUID,\n    document_id: UUID,\n    document: ConnectorDocumentUpdate,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; ConnectorDocumentResponse:\n    \"\"\"\n    Update a specific document.\n\n    Args:\n        connector_id: The ID of the connector.\n        document_id: The ID of the document to update.\n        document: The document update data.\n        service: The document service instance.\n        current_user: The currently authenticated admin user.\n\n    Returns:\n        ConnectorDocumentResponse: The updated document.\n    \"\"\"\n    return await service.update_document(document_id, document)\n</code></pre>"},{"location":"api/v1/dashboard/","title":"Dashboard","text":"<p>Dashboard Statistics API Endpoint.</p> <p>Provides REST endpoint for dashboard stats and manages periodic WebSocket broadcasts.</p>"},{"location":"api/v1/dashboard/#app.api.v1.endpoints.dashboard.broadcast_dashboard_stats_loop","title":"<code>broadcast_dashboard_stats_loop(interval_seconds=5)</code>  <code>async</code>","text":"<p>Background task that periodically broadcasts dashboard stats via WebSocket.</p> Source code in <code>app/api/v1/endpoints/dashboard.py</code> <pre><code>async def broadcast_dashboard_stats_loop(interval_seconds: int = 5) -&gt; None:\n    \"\"\"\n    Background task that periodically broadcasts dashboard stats via WebSocket.\n    \"\"\"\n    global _broadcast_running\n    _broadcast_running = True\n\n    logger.info(\"\ud83d\udcc8 START | dashboard_stats_broadcast | Interval: %ds\", interval_seconds)\n\n    # Late imports for clean dependency tree\n    from app.core.websocket import manager\n    from app.core.database import SessionLocal\n\n    try:\n        while _broadcast_running:\n            try:\n                # Create a fresh session per iteration to avoid pool/state issues\n                async with SessionLocal() as db:\n                    service = DashboardStatsService(db)\n                    stats = await service.get_all_stats()\n                    await manager.emit_dashboard_stats(stats.model_dump(mode=\"json\"))\n\n            except Exception as e:\n                logger.error(f\"\u26a0\ufe0f WARN | dashboard_stats_broadcast | Iteration Error: {e}\")\n\n            # Responsive sleep: allows faster shutdown if flag changes\n            # Wait in small increments or simply wait once if flag is enough\n            await asyncio.sleep(interval_seconds)\n    finally:\n        _broadcast_running = False\n        logger.info(\"\ud83d\udcc9 STOP | dashboard_stats_broadcast | Loop ended\")\n</code></pre>"},{"location":"api/v1/dashboard/#app.api.v1.endpoints.dashboard.get_dashboard_stats","title":"<code>get_dashboard_stats(db)</code>  <code>async</code>","text":"<p>Get current dashboard statistics (REST endpoint).</p> Source code in <code>app/api/v1/endpoints/dashboard.py</code> <pre><code>@router.get(\"/stats\", response_model=DashboardStats)\nasync def get_dashboard_stats(db: Annotated[AsyncSession, Depends(get_db)]) -&gt; DashboardStats:\n    \"\"\"\n    Get current dashboard statistics (REST endpoint).\n    \"\"\"\n    try:\n        service = DashboardStatsService(db)\n        return await service.get_all_stats()\n    except Exception as e:\n        logger.error(f\"\u274c FAIL | get_dashboard_stats | Error: {str(e)}\", exc_info=True)\n        # Exception handler in main.py will convert to standard JSON response\n        raise\n</code></pre>"},{"location":"api/v1/dashboard/#app.api.v1.endpoints.dashboard.start_broadcast_task","title":"<code>start_broadcast_task(interval_seconds=5)</code>  <code>async</code>","text":"<p>Start the periodic broadcast background task.</p> <p>Parameters:</p> <ul> <li> <code>interval_seconds</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Broadcast interval in seconds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>app/api/v1/endpoints/dashboard.py</code> <pre><code>async def start_broadcast_task(interval_seconds: int = 5) -&gt; None:\n    \"\"\"\n    Start the periodic broadcast background task.\n\n    Args:\n        interval_seconds: Broadcast interval in seconds.\n\n    Returns:\n        None\n    \"\"\"\n    global _broadcast_task, _broadcast_running\n\n    if _broadcast_task is not None and not _broadcast_task.done():\n        logger.warning(\"Dashboard broadcast task already running\")\n        return\n\n    _broadcast_running = True\n    _broadcast_task = asyncio.create_task(broadcast_dashboard_stats_loop(interval_seconds))\n    logger.info(\"Dashboard broadcast task started\")\n</code></pre>"},{"location":"api/v1/dashboard/#app.api.v1.endpoints.dashboard.stop_broadcast_task","title":"<code>stop_broadcast_task()</code>  <code>async</code>","text":"<p>Stop the periodic broadcast background task.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>app/api/v1/endpoints/dashboard.py</code> <pre><code>async def stop_broadcast_task() -&gt; None:\n    \"\"\"\n    Stop the periodic broadcast background task.\n\n    Returns:\n        None\n    \"\"\"\n    global _broadcast_task, _broadcast_running\n\n    if _broadcast_task is None:\n        return\n\n    _broadcast_running = False\n\n    # Wait for task to finish (should exit quickly after flag set)\n    try:\n        if _broadcast_task:\n            await asyncio.wait_for(_broadcast_task, timeout=10.0)\n    except (asyncio.TimeoutError, asyncio.CancelledError, Exception) as e:\n        if _broadcast_task:\n            logger.warning(f\"Dashboard broadcast task did not stop gracefully ({e}), cancelling\")\n            _broadcast_task.cancel()\n            try:\n                await _broadcast_task\n            except asyncio.CancelledError:\n                pass\n\n    _broadcast_task = None\n    logger.info(\"Dashboard broadcast task stopped\")\n</code></pre>"},{"location":"api/v1/files/","title":"Files","text":""},{"location":"api/v1/files/#app.api.v1.endpoints.files.stream_file","title":"<code>stream_file(document_id, file_service, current_user)</code>  <code>async</code>","text":"<p>Stream a file by its ID.</p> <p>Supports HTTP Range requests for audio/video seeking.</p> <p>Parameters:</p> <ul> <li> <code>document_id</code>               (<code>UUID</code>)           \u2013            <p>The unique identifier of the document to stream.</p> </li> <li> <code>file_service</code>               (<code>Annotated[FileService, Depends(get_file_service)]</code>)           \u2013            <p>Service for handling file operations.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_user)]</code>)           \u2013            <p>The currently authenticated user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FileResponse</code> (              <code>FileResponse</code> )          \u2013            <p>A response object that streams the file content.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>EntityNotFound</code>             \u2013            <p>If the file or document is not found.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If there is an unexpected error during streaming.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/files.py</code> <pre><code>@router.get(\"/stream/{document_id}\")\nasync def stream_file(\n    document_id: UUID,\n    file_service: Annotated[FileService, Depends(get_file_service)],\n    # Note: Audio elements often struggle with Auth headers.\n    # Ideally use a pre-signed URL or Cookie auth.\n    # For this strict refactor, we require auth. Frontend must attach token.\n    current_user: Annotated[User, Depends(get_current_user)],\n) -&gt; FileResponse:\n    \"\"\"\n    Stream a file by its ID.\n\n    Supports HTTP Range requests for audio/video seeking.\n\n    Args:\n        document_id: The unique identifier of the document to stream.\n        file_service: Service for handling file operations.\n        current_user: The currently authenticated user.\n\n    Returns:\n        FileResponse: A response object that streams the file content.\n\n    Raises:\n        EntityNotFound: If the file or document is not found.\n        TechnicalError: If there is an unexpected error during streaming.\n    \"\"\"\n    try:\n        stream_info = await file_service.get_file_for_streaming(document_id, current_user=current_user)\n\n        return FileResponse(\n            path=stream_info.file_path,\n            media_type=stream_info.media_type,\n            filename=stream_info.file_name,\n        )\n\n    except (EntityNotFound, TechnicalError) as e:\n        # FileResponse handles ranges automatically, but exceptions bubble up\n        if isinstance(e, EntityNotFound):\n            logger.warning(f\"File not found: {e}\")\n        else:\n            logger.error(f\"Stream file error: {e}\", exc_info=True)\n        raise e\n    except Exception as e:\n        logger.error(f\"Stream file unexpected error: {e}\", exc_info=True)\n        raise TechnicalError(message=f\"Could not stream file: {e}\", error_code=\"file_streaming_error\")\n</code></pre>"},{"location":"api/v1/notifications/","title":"Notifications","text":""},{"location":"api/v1/notifications/#app.api.v1.endpoints.notifications.MessageResponse","title":"<code>MessageResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic message response.</p> Source code in <code>app/api/v1/endpoints/notifications.py</code> <pre><code>class MessageResponse(BaseModel):\n    \"\"\"Generic message response.\"\"\"\n\n    message: str\n    success: bool = True\n</code></pre>"},{"location":"api/v1/notifications/#app.api.v1.endpoints.notifications.NotificationCreateRequest","title":"<code>NotificationCreateRequest</code>","text":"<p>               Bases: <code>NotificationBase</code></p> <p>Schema for creating a notification through the API.</p> Source code in <code>app/api/v1/endpoints/notifications.py</code> <pre><code>class NotificationCreateRequest(NotificationBase):\n    \"\"\"\n    Schema for creating a notification through the API.\n    \"\"\"\n\n    target_user_id: Optional[UUID] = Field(\n        default=None, description=\"The UUID of the user to notify (defaults to self if not provided)\"\n    )\n</code></pre>"},{"location":"api/v1/notifications/#app.api.v1.endpoints.notifications.clear_all_notifications","title":"<code>clear_all_notifications(service, current_user)</code>  <code>async</code>","text":"<p>Clear all notifications (Admin only).</p> Source code in <code>app/api/v1/endpoints/notifications.py</code> <pre><code>@router.delete(\"/\", response_model=MessageResponse)\nasync def clear_all_notifications(\n    service: Annotated[NotificationService, Depends(get_notification_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; MessageResponse:\n    \"\"\"\n    Clear all notifications (Admin only).\n    \"\"\"\n    try:\n        # Pass user context and confirmation\n        await service.clear_all_notifications(user_id=current_user.id, user_confirmation=True)\n        return MessageResponse(message=\"All notifications cleared\")\n    except Exception as e:\n        logger.error(f\"\u274c FAIL | clear_all_notifications | Error: {str(e)}\", exc_info=True)\n        raise TechnicalError(f\"Failed to clear all notifications: {e}\")\n</code></pre>"},{"location":"api/v1/notifications/#app.api.v1.endpoints.notifications.create_notification","title":"<code>create_notification(notification_in, service, current_user)</code>  <code>async</code>","text":"<p>Create a notification (Admin only).</p> <p>If target_user_id is provided, the notification will be created for that user. Otherwise, it will be created for the admin currently authenticated.</p> Source code in <code>app/api/v1/endpoints/notifications.py</code> <pre><code>@router.post(\"/\", response_model=NotificationResponse)\nasync def create_notification(\n    notification_in: NotificationCreateRequest,\n    service: Annotated[NotificationService, Depends(get_notification_service)],\n    current_user: Annotated[User, Depends(get_current_admin)],\n) -&gt; NotificationResponse:\n    \"\"\"\n    Create a notification (Admin only).\n\n    If target_user_id is provided, the notification will be created for that user.\n    Otherwise, it will be created for the admin currently authenticated.\n    \"\"\"\n    try:\n        # P0: Allow admin to notify others\n        target_id = notification_in.target_user_id or current_user.id\n\n        notification = NotificationCreate(**notification_in.model_dump(exclude={\"target_user_id\"}), user_id=target_id)\n        return await service.create_notification(notification)\n    except Exception as e:\n        logger.error(f\"\u274c FAIL | create_notification | Error: {str(e)}\", exc_info=True)\n        if isinstance(e, (FunctionalError, TechnicalError)):\n            raise\n        raise TechnicalError(f\"Failed to create notification: {e}\")\n</code></pre>"},{"location":"api/v1/notifications/#app.api.v1.endpoints.notifications.get_notifications","title":"<code>get_notifications(service, current_user)</code>  <code>async</code>","text":"<p>List all notifications for the current user.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[NotificationService, Depends(get_notification_service)]</code>)           \u2013            <p>The notification service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_user)]</code>)           \u2013            <p>The currently authenticated user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[NotificationResponse]</code>           \u2013            <p>List[NotificationResponse]: A list of notifications for the user.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TechnicalError</code>             \u2013            <p>If there's an error fetching notifications.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/notifications.py</code> <pre><code>@router.get(\"/\", response_model=List[NotificationResponse])\nasync def get_notifications(\n    service: Annotated[NotificationService, Depends(get_notification_service)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -&gt; List[NotificationResponse]:\n    \"\"\"\n    List all notifications for the current user.\n\n    Args:\n        service: The notification service instance.\n        current_user: The currently authenticated user.\n\n    Returns:\n        List[NotificationResponse]: A list of notifications for the user.\n\n    Raises:\n        TechnicalError: If there's an error fetching notifications.\n    \"\"\"\n    try:\n        return await service.get_notifications(user_id=current_user.id)\n    except Exception as e:\n        logger.error(f\"\u274c FAIL | get_notifications | Error: {str(e)}\", exc_info=True)\n        raise TechnicalError(f\"Failed to fetch notifications: {e}\")\n</code></pre>"},{"location":"api/v1/notifications/#app.api.v1.endpoints.notifications.mark_all_notifications_read","title":"<code>mark_all_notifications_read(service, current_user)</code>  <code>async</code>","text":"<p>Mark all notifications as read for the current user.</p> Source code in <code>app/api/v1/endpoints/notifications.py</code> <pre><code>@router.put(\"/read\", response_model=MessageResponse)\nasync def mark_all_notifications_read(\n    service: Annotated[NotificationService, Depends(get_notification_service)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -&gt; MessageResponse:\n    \"\"\"\n    Mark all notifications as read for the current user.\n    \"\"\"\n    try:\n        # Pass user context and confirmation\n        await service.mark_all_as_read(user_id=current_user.id, user_confirmation=True)\n        return MessageResponse(message=\"All notifications marked as read\")\n    except Exception as e:\n        logger.error(f\"\u274c FAIL | mark_all_notifications_read | Error: {str(e)}\", exc_info=True)\n        raise TechnicalError(f\"Failed to mark all notifications as read: {e}\")\n</code></pre>"},{"location":"api/v1/notifications/#app.api.v1.endpoints.notifications.mark_notification_read","title":"<code>mark_notification_read(notification_id, service, current_user)</code>  <code>async</code>","text":"<p>Mark a specific notification as read.</p> Source code in <code>app/api/v1/endpoints/notifications.py</code> <pre><code>@router.put(\"/{notification_id}/read\", response_model=NotificationResponse)\nasync def mark_notification_read(\n    notification_id: UUID,\n    service: Annotated[NotificationService, Depends(get_notification_service)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -&gt; NotificationResponse:\n    \"\"\"\n    Mark a specific notification as read.\n    \"\"\"\n    try:\n        notification = await service.mark_notification_as_read(user_id=current_user.id, notification_id=notification_id)\n        if not notification:\n            # Should technically be handled by service raising EntityNotFound\n            raise EntityNotFound(\"Notification not found\")\n        return notification\n    except EntityNotFound:\n        raise\n    except Exception as e:\n        logger.error(\n            f\"\u274c FAIL | mark_notification_read | ID: {notification_id} | Error: {str(e)}\",\n            exc_info=True,\n        )\n        raise TechnicalError(f\"Failed to mark notification as read: {e}\")\n</code></pre>"},{"location":"api/v1/notifications/#app.api.v1.endpoints.notifications.stream_notifications","title":"<code>stream_notifications(request, current_user, manager=Depends(get_websocket))</code>  <code>async</code>","text":"<p>SSE Stream for real-time notifications.</p> <p>Provides a Server-Sent Events (SSE) stream that delivers real-time notifications to the authenticated user.</p> <p>Parameters:</p> <ul> <li> <code>request</code>               (<code>Request</code>)           \u2013            <p>The FastAPI request object.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_user)]</code>)           \u2013            <p>The currently authenticated user.</p> </li> <li> <code>manager</code>               (<code>Websocket</code>, default:                   <code>Depends(get_websocket)</code> )           \u2013            <p>The websocket manager instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>StreamingResponse</code> (              <code>StreamingResponse</code> )          \u2013            <p>A response delivering SSE events.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/notifications.py</code> <pre><code>@router.get(\"/stream\")\nasync def stream_notifications(\n    request: Request,\n    current_user: Annotated[User, Depends(get_current_user)],\n    manager: Websocket = Depends(get_websocket),\n) -&gt; StreamingResponse:\n    \"\"\"\n    SSE Stream for real-time notifications.\n\n    Provides a Server-Sent Events (SSE) stream that delivers real-time notifications\n    to the authenticated user.\n\n    Args:\n        request: The FastAPI request object.\n        current_user: The currently authenticated user.\n        manager: The websocket manager instance.\n\n    Returns:\n        StreamingResponse: A response delivering SSE events.\n    \"\"\"\n\n    async def event_generator() -&gt; AsyncGenerator[str, None]:\n        \"\"\"\n        Generates SSE events from the connection manager.\n\n        Yields:\n            str: Formatted SSE data strings.\n        \"\"\"\n        # \"The Architect Way\": Use the safe generator that guarantees cleanup and capped queues\n        async for message in manager.stream_events():\n            if await request.is_disconnected():\n                break\n            yield f\"data: {message}\\n\\n\"\n\n    return StreamingResponse(event_generator(), media_type=\"text/event-stream\")\n</code></pre>"},{"location":"api/v1/pricing/","title":"Pricing","text":""},{"location":"api/v1/pricing/#app.api.v1.endpoints.pricing.get_pricing","title":"<code>get_pricing(service)</code>  <code>async</code>","text":"<p>Returns the current pricing configuration for models (embeddings and generative).</p> <p>Prices are in USD per 1000 tokens.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[PricingService, Depends(get_pricing_service)]</code>)           \u2013            <p>The pricing service instance injected by FastAPI.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PricingMapResponse</code> (              <code>PricingMapResponse</code> )          \u2013            <p>A dictionary containing the pricing for different models.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TechnicalError</code>             \u2013            <p>If there's an error retrieving the pricing configuration.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/pricing.py</code> <pre><code>@router.get(\"/\", response_model=PricingMapResponse, summary=\"Get current model pricing\")\nasync def get_pricing(\n    service: Annotated[PricingService, Depends(get_pricing_service)],\n) -&gt; PricingMapResponse:\n    \"\"\"\n    Returns the current pricing configuration for models (embeddings and generative).\n\n    Prices are in USD per 1000 tokens.\n\n    Args:\n        service: The pricing service instance injected by FastAPI.\n\n    Returns:\n        PricingMapResponse: A dictionary containing the pricing for different models.\n\n    Raises:\n        TechnicalError: If there's an error retrieving the pricing configuration.\n    \"\"\"\n    try:\n        return await service.get_pricing_map()\n\n    except Exception as e:\n        logger.error(f\"\u274c FAIL | get_pricing | Error: {str(e)}\", exc_info=True)\n        raise TechnicalError(\n            message=f\"Failed to retrieve pricing: {e}\",\n            error_code=\"PRICING_FETCH_ERROR\",\n        )\n</code></pre>"},{"location":"api/v1/prompts/","title":"Prompts","text":""},{"location":"api/v1/prompts/#app.api.v1.endpoints.prompts.OptimizeRequest","title":"<code>OptimizeRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema for prompt optimization request.</p> <p>Attributes:</p> <ul> <li> <code>instruction</code>               (<code>str</code>)           \u2013            <p>The user instruction to optimize.</p> </li> <li> <code>connector_ids</code>               (<code>List[str]</code>)           \u2013            <p>List of connector IDs to provide context for optimization.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/prompts.py</code> <pre><code>class OptimizeRequest(BaseModel):\n    \"\"\"\n    Schema for prompt optimization request.\n\n    Attributes:\n        instruction: The user instruction to optimize.\n        connector_ids: List of connector IDs to provide context for optimization.\n    \"\"\"\n\n    instruction: str = Field(..., min_length=1, max_length=5000, description=\"The user instruction to optimize\")\n    connector_ids: List[str] = Field(\n        default_factory=list, description=\"List of connector IDs to provide context for optimization\"\n    )\n</code></pre>"},{"location":"api/v1/prompts/#app.api.v1.endpoints.prompts.OptimizeResponse","title":"<code>OptimizeResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema for prompt optimization response.</p> <p>Attributes:</p> <ul> <li> <code>optimized_instruction</code>               (<code>str</code>)           \u2013            <p>The optimized version of the instruction.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/prompts.py</code> <pre><code>class OptimizeResponse(BaseModel):\n    \"\"\"\n    Schema for prompt optimization response.\n\n    Attributes:\n        optimized_instruction: The optimized version of the instruction.\n    \"\"\"\n\n    optimized_instruction: str = Field(..., description=\"The optimized version of the instruction\")\n</code></pre>"},{"location":"api/v1/prompts/#app.api.v1.endpoints.prompts.optimize_prompt","title":"<code>optimize_prompt(request, service, current_user)</code>  <code>async</code>","text":"<p>Optimizes a user instruction using LLM and context from connectors.</p> <p>Parameters:</p> <ul> <li> <code>request</code>               (<code>OptimizeRequest</code>)           \u2013            <p>The optimization request containing instruction and connector IDs.</p> </li> <li> <code>service</code>               (<code>Annotated[PromptService, Depends(get_prompt_service)]</code>)           \u2013            <p>The prompt service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_user)]</code>)           \u2013            <p>The currently authenticated user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptimizeResponse</code> (              <code>OptimizeResponse</code> )          \u2013            <p>The response containing the optimized instruction.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FunctionalError</code>             \u2013            <p>If there's a functional error during optimization.</p> </li> <li> <code>TechnicalError</code>             \u2013            <p>If there's a technical error during optimization.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/prompts.py</code> <pre><code>@router.post(\"/optimize\", response_model=OptimizeResponse)\nasync def optimize_prompt(\n    request: OptimizeRequest,\n    service: Annotated[PromptService, Depends(get_prompt_service)],\n    current_user: Annotated[User, Depends(get_current_user)],  # \ud83d\udee1\ufe0f SECURITY: Require Auth\n) -&gt; OptimizeResponse:\n    \"\"\"\n    Optimizes a user instruction using LLM and context from connectors.\n\n    Args:\n        request: The optimization request containing instruction and connector IDs.\n        service: The prompt service instance.\n        current_user: The currently authenticated user.\n\n    Returns:\n        OptimizeResponse: The response containing the optimized instruction.\n\n    Raises:\n        FunctionalError: If there's a functional error during optimization.\n        TechnicalError: If there's a technical error during optimization.\n    \"\"\"\n    start_time = time.time()\n    func_name = \"optimize_prompt\"\n    logger.info(\n        \"START | %s | User: %s | Params: {'connector_count': %d}\",\n        func_name,\n        current_user.email,\n        len(request.connector_ids),\n    )\n\n    try:\n        # Note: connector_ids currently unused in service but kept for future RAG context injection\n        optimized_text = await service.optimize_instruction(request.instruction)\n\n        elapsed = round((time.time() - start_time) * 1000, 2)\n        logger.info(\"FINISH | %s | Status: Success | Duration: %sms\", func_name, elapsed)\n\n        return OptimizeResponse(optimized_instruction=optimized_text)\n\n    except (FunctionalError, TechnicalError) as e:\n        logger.error(\"\u274c FAIL | %s | Known Error: %s (Code: %s)\", func_name, e.message, e.error_code, exc_info=True)\n        raise e\n    except Exception as e:\n        logger.error(\"\u274c FAIL | %s | Error: %s\", func_name, str(e), exc_info=True)\n        raise TechnicalError(message=f\"Failed to optimize prompt: {e}\", error_code=\"PROMPT_OPTIMIZATION_FAILED\")\n</code></pre>"},{"location":"api/v1/providers/","title":"Providers","text":""},{"location":"api/v1/providers/#app.api.v1.endpoints.providers.get_providers","title":"<code>get_providers(service)</code>  <code>async</code>","text":"<p>Retrieve the list of supported providers and their configuration status. This allows the frontend to dynamically display available options.</p> Source code in <code>app/api/v1/endpoints/providers.py</code> <pre><code>@router.get(\"/\", response_model=List[ProviderInfo])\nasync def get_providers(\n    service: Annotated[SettingsService, Depends(get_settings_service)],\n) -&gt; Any:\n    \"\"\"\n    Retrieve the list of supported providers and their configuration status.\n    This allows the frontend to dynamically display available options.\n    \"\"\"\n    providers = []\n\n    # Helper to check if key exists (in DB or Env via SettingsService fallback)\n    async def is_configured(key: str) -&gt; bool:\n        val = await service.get_value(key)\n        if val is None:\n            return False\n        val = str(val).strip()\n        # Consider empty or single asterisks (masked) as not configured\n        return bool(val and val != \"\" and not all(c == \"*\" for c in val))\n\n    # --- Embedding Providers ---\n    # Ollama\n    providers.append(\n        ProviderInfo(\n            id=\"ollama\",\n            name=\"Ollama (Local)\",\n            type=\"embedding\",\n            description=\"GPU Accelerated &amp; Efficient\",\n            configured=await is_configured(\"ollama_base_url\") or True,  # Default is configured (localhost)\n            is_active=True,\n            supported_models=SUPPORTED_EMBEDDING_MODELS.get(\"ollama\", []),\n            supported_transcription_models=SUPPORTED_TRANSCRIPTION_MODELS.get(\"ollama\", []),\n        )\n    )\n\n    # Gemini\n    providers.append(\n        ProviderInfo(\n            id=\"gemini\",\n            name=\"Google Gemini\",\n            type=\"embedding\",\n            description=\"Google DeepMind\",\n            configured=await is_configured(\"gemini_api_key\"),\n            is_active=True,\n            supported_models=SUPPORTED_EMBEDDING_MODELS.get(\"gemini\", []),\n            supported_transcription_models=SUPPORTED_TRANSCRIPTION_MODELS.get(\"gemini\", []),\n        )\n    )\n\n    # OpenAI\n    providers.append(\n        ProviderInfo(\n            id=\"openai\",\n            name=\"OpenAI\",\n            type=\"embedding\",\n            description=\"Standard Industry Model\",\n            configured=await is_configured(\"openai_api_key\"),\n            is_active=True,\n            supported_models=SUPPORTED_EMBEDDING_MODELS.get(\"openai\", []),\n            supported_transcription_models=SUPPORTED_TRANSCRIPTION_MODELS.get(\"openai\", []),\n        )\n    )\n\n    # --- Chat Providers ---\n    # Ollama (Local)\n    providers.append(\n        ProviderInfo(\n            id=\"ollama\",\n            name=\"Ollama (Local)\",\n            type=\"chat\",\n            description=\"Run models locally\",\n            configured=True,\n            is_active=True,\n            supported_models=SUPPORTED_CHAT_MODELS.get(\"ollama\", []),\n        )\n    )\n\n    # Gemini\n    providers.append(\n        ProviderInfo(\n            id=\"gemini\",\n            name=\"Google Gemini\",\n            type=\"chat\",\n            description=\"Google DeepMind\",\n            configured=await is_configured(\"gemini_api_key\"),\n            is_active=True,\n            supported_models=SUPPORTED_CHAT_MODELS.get(\"gemini\", []),\n        )\n    )\n\n    # OpenAI\n    providers.append(\n        ProviderInfo(\n            id=\"openai\",\n            name=\"OpenAI\",\n            type=\"chat\",\n            description=\"ChatGPT\",\n            configured=await is_configured(\"openai_api_key\"),\n            is_active=True,\n            supported_models=SUPPORTED_CHAT_MODELS.get(\"openai\", []),\n        )\n    )\n\n    # Mistral\n    providers.append(\n        ProviderInfo(\n            id=\"mistral\",\n            name=\"Mistral AI\",\n            type=\"chat\",\n            description=\"European Champion\",\n            configured=await is_configured(\"mistral_api_key\"),\n            is_active=True,\n            supported_models=SUPPORTED_CHAT_MODELS.get(\"mistral\", []),\n        )\n    )\n\n    # Anthropic\n    providers.append(\n        ProviderInfo(\n            id=\"anthropic\",\n            name=\"Anthropic Claude\",\n            type=\"chat\",\n            description=\"Constitutional AI\",\n            configured=await is_configured(\"anthropic_api_key\"),\n            is_active=True,\n            supported_models=SUPPORTED_CHAT_MODELS.get(\"anthropic\", []),\n        )\n    )\n\n    # --- Pertinence Providers ---\n\n    # Local (FastEmbed)\n    providers.append(\n        ProviderInfo(\n            id=\"local\",\n            name=\"Pertinence Local (FastEmbed)\",\n            type=\"rerank\",\n            description=\"Private &amp; Efficient (CPU)\",\n            configured=True,  # FastEmbed is built-in\n            is_active=True,\n            supported_models=SUPPORTED_RERANK_MODELS.get(\"local\", []),\n        )\n    )\n\n    # Cohere\n    providers.append(\n        ProviderInfo(\n            id=\"cohere\",\n            name=\"Cohere\",\n            type=\"rerank\",\n            description=\"Industry leader in Relevance\",\n            configured=await is_configured(\"cohere_api_key\"),\n            is_active=True,\n            supported_models=SUPPORTED_RERANK_MODELS.get(\"cohere\", []),\n        )\n    )\n\n    return providers\n</code></pre>"},{"location":"api/v1/settings/","title":"Settings","text":"<p>Settings API endpoints.</p>"},{"location":"api/v1/settings/#app.api.v1.endpoints.settings.get_settings","title":"<code>get_settings(service, current_user)</code>  <code>async</code>","text":"<p>List all settings with secrets masked.</p> <p>This endpoint ensures default settings exist (self-healing) and returns all settings. Secrets are masked with asterisks for security. Logged in users only.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[SettingsService, Depends(get_settings_service)]</code>)           \u2013            <p>The settings service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_user)]</code>)           \u2013            <p>The currently authenticated user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[SettingResponse]</code>           \u2013            <p>List[SettingResponse]: A list of settings with masked secret values.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TechnicalError</code>             \u2013            <p>If there is an error fetching the settings.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/settings.py</code> <pre><code>@router.get(\"/\", response_model=List[SettingResponse])\nasync def get_settings(\n    service: Annotated[SettingsService, Depends(get_settings_service)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -&gt; List[SettingResponse]:\n    \"\"\"\n    List all settings with secrets masked.\n\n    This endpoint ensures default settings exist (self-healing) and returns all\n    settings. Secrets are masked with asterisks for security.\n    Logged in users only.\n\n    Args:\n        service: The settings service instance.\n        current_user: The currently authenticated user.\n\n    Returns:\n        List[SettingResponse]: A list of settings with masked secret values.\n\n    Raises:\n        TechnicalError: If there is an error fetching the settings.\n    \"\"\"\n    try:\n        # Self-healing: ensure defaults exist\n        await service.seed_defaults()\n\n        settings = await service.get_all_settings()\n\n        # Mask secrets for display\n        return _mask_secrets(settings)\n\n    except Exception as e:\n        logger.error(f\"\u274c FAIL | get_settings | Error: {str(e)}\", exc_info=True)\n        raise TechnicalError(f\"Failed to fetch settings: {e}\") from e\n</code></pre>"},{"location":"api/v1/settings/#app.api.v1.endpoints.settings.update_settings","title":"<code>update_settings(settings_in, service, current_admin)</code>  <code>async</code>","text":"<p>Batch update settings.</p> <p>This endpoint allows administrators to update multiple settings at once. Secrets in the response are masked.</p> <p>Parameters:</p> <ul> <li> <code>settings_in</code>               (<code>List[SettingUpdate]</code>)           \u2013            <p>A list of settings to update.</p> </li> <li> <code>service</code>               (<code>Annotated[SettingsService, Depends(get_settings_service)]</code>)           \u2013            <p>The settings service instance.</p> </li> <li> <code>current_admin</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated administrator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[SettingResponse]</code>           \u2013            <p>List[SettingResponse]: A list of the updated settings with masked secret values.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TechnicalError</code>             \u2013            <p>If there is an error updating the settings.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/settings.py</code> <pre><code>@router.put(\"/\", response_model=List[SettingResponse])\nasync def update_settings(\n    settings_in: List[SettingUpdate],\n    service: Annotated[SettingsService, Depends(get_settings_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n) -&gt; List[SettingResponse]:\n    \"\"\"\n    Batch update settings.\n\n    This endpoint allows administrators to update multiple settings at once.\n    Secrets in the response are masked.\n\n    Args:\n        settings_in: A list of settings to update.\n        service: The settings service instance.\n        current_admin: The currently authenticated administrator.\n\n    Returns:\n        List[SettingResponse]: A list of the updated settings with masked secret values.\n\n    Raises:\n        TechnicalError: If there is an error updating the settings.\n    \"\"\"\n    try:\n        # Convert Pydantic schemas to list of dicts for service\n        updates = [s.model_dump(exclude_unset=True) for s in settings_in]\n\n        # Transactional Batch Update\n        updated_settings = await service.update_settings_batch(updates)\n\n        # Mask secrets in response\n        return _mask_secrets(updated_settings)\n\n    except Exception as e:\n        logger.error(f\"\u274c FAIL | update_settings | Error: {str(e)}\", exc_info=True)\n        raise TechnicalError(f\"Failed to update settings: {e}\") from e\n</code></pre>"},{"location":"api/v1/system/","title":"System","text":""},{"location":"api/v1/system/#app.api.v1.endpoints.system.DeleteTempFileRequest","title":"<code>DeleteTempFileRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for deleting a temporary file.</p> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path of the temporary file to delete.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/system.py</code> <pre><code>class DeleteTempFileRequest(BaseModel):\n    \"\"\"\n    Request model for deleting a temporary file.\n\n    Attributes:\n        path: The path of the temporary file to delete.\n    \"\"\"\n\n    path: str\n</code></pre>"},{"location":"api/v1/system/#app.api.v1.endpoints.system.FilePathResponse","title":"<code>FilePathResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>File path response.</p> Source code in <code>app/api/v1/endpoints/system.py</code> <pre><code>class FilePathResponse(BaseModel):\n    \"\"\"File path response.\"\"\"\n\n    path: str\n</code></pre>"},{"location":"api/v1/system/#app.api.v1.endpoints.system.MessageResponse","title":"<code>MessageResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic message response.</p> Source code in <code>app/api/v1/endpoints/system.py</code> <pre><code>class MessageResponse(BaseModel):\n    \"\"\"Generic message response.\"\"\"\n\n    message: str\n    success: bool = True\n</code></pre>"},{"location":"api/v1/system/#app.api.v1.endpoints.system.OpenFileRequest","title":"<code>OpenFileRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for opening a file.</p> <p>Attributes:</p> <ul> <li> <code>document_id</code>               (<code>str</code>)           \u2013            <p>The ID of the document to open.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/system.py</code> <pre><code>class OpenFileRequest(BaseModel):\n    \"\"\"\n    Request model for opening a file.\n\n    Attributes:\n        document_id: The ID of the document to open.\n    \"\"\"\n\n    document_id: str\n</code></pre>"},{"location":"api/v1/system/#app.api.v1.endpoints.system.delete_temp_file","title":"<code>delete_temp_file(request, service, current_admin)</code>  <code>async</code>","text":"<p>Delete a temporary uploaded file.</p> <p>Admin only. Used when user cancels connector creation after uploading.</p> <p>Parameters:</p> <ul> <li> <code>request</code>               (<code>DeleteTempFileRequest</code>)           \u2013            <p>The request body containing the file path.</p> </li> <li> <code>service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_admin</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MessageResponse</code>           \u2013            <p>A dictionary containing a success message.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there's an error during file deletion.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/system.py</code> <pre><code>@router.delete(\"/temp-file\", response_model=MessageResponse)\nasync def delete_temp_file(\n    request: DeleteTempFileRequest,\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n) -&gt; MessageResponse:\n    \"\"\"\n    Delete a temporary uploaded file.\n\n    Admin only.\n    Used when user cancels connector creation after uploading.\n\n    Args:\n        request: The request body containing the file path.\n        service: The document service instance.\n        current_admin: The currently authenticated admin user.\n\n    Returns:\n        A dictionary containing a success message.\n\n    Raises:\n        Exception: If there's an error during file deletion.\n    \"\"\"\n    try:\n        await service.delete_temp_file(request.path)\n        return {\"message\": \"File deleted successfully\"}\n    except Exception as e:\n        logger.error(\n            f\"\u274c FAIL | delete_temp_file | Path: {request.path} | Error: {str(e)}\",\n            exc_info=True,\n        )\n        raise e\n</code></pre>"},{"location":"api/v1/system/#app.api.v1.endpoints.system.open_file_external","title":"<code>open_file_external(request, service, current_user)</code>  <code>async</code>","text":"<p>Open a file using the system's default application based on document ID.</p> <p>Reconstructs the full path using connector configuration. Basic auth required.</p> <p>Parameters:</p> <ul> <li> <code>request</code>               (<code>OpenFileRequest</code>)           \u2013            <p>The request body containing document_id.</p> </li> <li> <code>service</code>               (<code>Annotated[SystemService, Depends(get_system_service)]</code>)           \u2013            <p>The system service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_user)]</code>)           \u2013            <p>The currently authenticated user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MessageResponse</code>           \u2013            <p>A dictionary containing the status of the operation.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there's an error opening the file.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/system.py</code> <pre><code>@router.post(\"/open-file\", response_model=MessageResponse)\nasync def open_file_external(\n    request: OpenFileRequest,\n    service: Annotated[SystemService, Depends(get_system_service)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -&gt; MessageResponse:\n    \"\"\"\n    Open a file using the system's default application based on document ID.\n\n    Reconstructs the full path using connector configuration.\n    Basic auth required.\n\n    Args:\n        request: The request body containing document_id.\n        service: The system service instance.\n        current_user: The currently authenticated user.\n\n    Returns:\n        A dictionary containing the status of the operation.\n\n    Raises:\n        Exception: If there's an error opening the file.\n    \"\"\"\n    try:\n        success = await service.open_file_by_document_id(request.document_id)\n        return {\"message\": \"File opened\", \"success\": success}\n    except Exception as e:\n        logger.error(\n            f\"\u274c FAIL | open_file_external | DocumentID: {request.document_id} | Error: {str(e)}\",\n            exc_info=True,\n        )\n        raise e\n</code></pre>"},{"location":"api/v1/system/#app.api.v1.endpoints.system.upload_file","title":"<code>upload_file(service, current_admin, file=File(...))</code>  <code>async</code>","text":"<p>Upload a file to the temporary area.</p> <p>Admin only.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[DocumentService, Depends(get_document_service)]</code>)           \u2013            <p>The document service instance.</p> </li> <li> <code>current_admin</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> <li> <code>file</code>               (<code>UploadFile</code>, default:                   <code>File(...)</code> )           \u2013            <p>The file to be uploaded.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FilePathResponse</code>           \u2013            <p>A dictionary containing the path of the uploaded file.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there's an error during file upload.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/system.py</code> <pre><code>@router.post(\"/upload\", response_model=FilePathResponse)\nasync def upload_file(\n    service: Annotated[DocumentService, Depends(get_document_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n    file: UploadFile = File(...),\n) -&gt; FilePathResponse:\n    \"\"\"\n    Upload a file to the temporary area.\n\n    Admin only.\n\n    Args:\n        service: The document service instance.\n        current_admin: The currently authenticated admin user.\n        file: The file to be uploaded.\n\n    Returns:\n        A dictionary containing the path of the uploaded file.\n\n    Raises:\n        Exception: If there's an error during file upload.\n    \"\"\"\n    try:\n        # Delegate to Service\n        file_path = await service.upload_file(file)\n        return {\"path\": file_path}\n    except Exception as e:\n        logger.error(f\"\u274c FAIL | upload_file | Error: {str(e)}\", exc_info=True)\n        raise e\n</code></pre>"},{"location":"api/v1/trending/","title":"Trending","text":""},{"location":"api/v1/trending/#app.api.v1.endpoints.trending.get_trending_topics","title":"<code>get_trending_topics(service, assistant_id=Query(None, description='Filter by Assistant ID.'), limit=Query(10, ge=1, le=50, description='Max number of topics to return'))</code>  <code>async</code>","text":"<p>Get top trending questions (semantic clusters).</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[TrendingService, Depends(get_trending_service)]</code>)           \u2013            <p>The trending service instance.</p> </li> <li> <code>assistant_id</code>               (<code>Optional[UUID]</code>, default:                   <code>Query(None, description='Filter by Assistant ID.')</code> )           \u2013            <p>Optional UUID to filter by a specific assistant.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>Query(10, ge=1, le=50, description='Max number of topics to return')</code> )           \u2013            <p>Maximum number of trending topics to return (1-50).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[TopicStatResponse]</code>           \u2013            <p>List[TopicStatResponse]: A list of trending topics with their statistics.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TechnicalError</code>             \u2013            <p>If there's an error fetching the trending topics.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/trending.py</code> <pre><code>@router.get(\"/\", response_model=List[TopicStatResponse])\nasync def get_trending_topics(\n    service: Annotated[TrendingService, Depends(get_trending_service)],\n    assistant_id: Optional[UUID] = Query(None, description=\"Filter by Assistant ID.\"),\n    limit: int = Query(10, ge=1, le=50, description=\"Max number of topics to return\"),\n) -&gt; List[TopicStatResponse]:\n    \"\"\"\n    Get top trending questions (semantic clusters).\n\n    Args:\n        service: The trending service instance.\n        assistant_id: Optional UUID to filter by a specific assistant.\n        limit: Maximum number of trending topics to return (1-50).\n\n    Returns:\n        List[TopicStatResponse]: A list of trending topics with their statistics.\n\n    Raises:\n        TechnicalError: If there's an error fetching the trending topics.\n    \"\"\"\n    try:\n        # Note: TrendingService.get_trending_topics already handles optional assistant_id\n        # and will filter if provided.\n        topics = await service.get_trending_topics(assistant_id=assistant_id, limit=limit)\n\n        return topics\n\n    except Exception as e:\n        logger.error(f\"\u274c FAIL | get_trending_topics | Error: {str(e)}\", exc_info=True)\n        raise TechnicalError(f\"Failed to fetch trending topics: {e}\")\n</code></pre>"},{"location":"api/v1/users/","title":"Users","text":""},{"location":"api/v1/users/#app.api.v1.endpoints.users.create_user","title":"<code>create_user(*, user_in, service, current_admin)</code>  <code>async</code>","text":"<p>Create new user. Admin only.</p> <p>Parameters:</p> <ul> <li> <code>user_in</code>               (<code>UserCreate</code>)           \u2013            <p>The user creation data.</p> </li> <li> <code>service</code>               (<code>Annotated[UserService, Depends(get_user_service)]</code>)           \u2013            <p>The user service instance.</p> </li> <li> <code>current_admin</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>User</code> (              <code>User</code> )          \u2013            <p>The created user object.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.post(\"/\", response_model=UserRead)\nasync def create_user(\n    *,\n    user_in: UserCreate,\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n) -&gt; User:\n    \"\"\"\n    Create new user. Admin only.\n\n    Args:\n        user_in: The user creation data.\n        service: The user service instance.\n        current_admin: The currently authenticated admin user.\n\n    Returns:\n        User: The created user object.\n    \"\"\"\n    return await service.create(user_in)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.delete_user","title":"<code>delete_user(*, user_id, service, current_admin)</code>  <code>async</code>","text":"<p>Delete a user. Admin only.</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the user to delete.</p> </li> <li> <code>service</code>               (<code>Annotated[UserService, Depends(get_user_service)]</code>)           \u2013            <p>The user service instance.</p> </li> <li> <code>current_admin</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>User</code> (              <code>User</code> )          \u2013            <p>The deleted user object.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.delete(\"/{user_id}\", response_model=UserRead)\nasync def delete_user(\n    *,\n    user_id: UUID,\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n) -&gt; User:\n    \"\"\"\n    Delete a user. Admin only.\n\n    Args:\n        user_id: The ID of the user to delete.\n        service: The user service instance.\n        current_admin: The currently authenticated admin user.\n\n    Returns:\n        User: The deleted user object.\n    \"\"\"\n    return await service.delete(user_id)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.delete_user_avatar","title":"<code>delete_user_avatar(*, user_id, service, current_user)</code>  <code>async</code>","text":"<p>Remove the avatar image from a user.</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the user.</p> </li> <li> <code>service</code>               (<code>Annotated[UserService, Depends(get_user_service)]</code>)           \u2013            <p>The user service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_user)]</code>)           \u2013            <p>The currently authenticated user.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>If the user is not authorized.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>User</code> (              <code>User</code> )          \u2013            <p>The updated user object.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.delete(\"/{user_id}/avatar\", response_model=UserRead)\nasync def delete_user_avatar(\n    *,\n    user_id: UUID,\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -&gt; User:\n    \"\"\"\n    Remove the avatar image from a user.\n\n    Args:\n        user_id: The ID of the user.\n        service: The user service instance.\n        current_user: The currently authenticated user.\n\n    Raises:\n        HTTPException: If the user is not authorized.\n\n    Returns:\n        User: The updated user object.\n    \"\"\"\n    if current_user.id != user_id and current_user.role != UserRole.ADMIN:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    return await service.remove_avatar(user_id)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.get_user_avatar","title":"<code>get_user_avatar(*, user_id, service)</code>  <code>async</code>","text":"<p>Get the avatar image file for a user.</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the user.</p> </li> <li> <code>service</code>               (<code>Annotated[UserService, Depends(get_user_service)]</code>)           \u2013            <p>The user service instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>If the avatar is not found.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FileResponse</code> (              <code>FileResponse</code> )          \u2013            <p>The avatar image file.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.get(\"/{user_id}/avatar\")\nasync def get_user_avatar(\n    *,\n    user_id: UUID,\n    service: Annotated[UserService, Depends(get_user_service)],\n) -&gt; FileResponse:\n    \"\"\"\n    Get the avatar image file for a user.\n\n    Args:\n        user_id: The ID of the user.\n        service: The user service instance.\n\n    Raises:\n        HTTPException: If the avatar is not found.\n\n    Returns:\n        FileResponse: The avatar image file.\n    \"\"\"\n    file_path = await service.get_avatar_path(user_id)\n    if not file_path:\n        raise HTTPException(status_code=404, detail=\"Avatar not found\")\n\n    return FileResponse(file_path)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.read_user_me","title":"<code>read_user_me(current_user)</code>  <code>async</code>","text":"<p>Get current user.</p> <p>Parameters:</p> <ul> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_user)]</code>)           \u2013            <p>The currently authenticated user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>User</code> (              <code>User</code> )          \u2013            <p>The current user object.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.get(\"/me\", response_model=UserRead)\nasync def read_user_me(current_user: Annotated[User, Depends(get_current_user)]) -&gt; User:\n    \"\"\"\n    Get current user.\n\n    Args:\n        current_user: The currently authenticated user.\n\n    Returns:\n        User: The current user object.\n    \"\"\"\n    return current_user\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.read_users","title":"<code>read_users(service, current_admin, skip=0, limit=100)</code>  <code>async</code>","text":"<p>Retrieve users. Admin only.</p> <p>Parameters:</p> <ul> <li> <code>service</code>               (<code>Annotated[UserService, Depends(get_user_service)]</code>)           \u2013            <p>The user service instance.</p> </li> <li> <code>current_admin</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> <li> <code>skip</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of records to skip.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>Maximum number of records to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[User]</code>           \u2013            <p>List[User]: A list of users.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.get(\"/\", response_model=List[UserRead])\nasync def read_users(\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n    skip: int = 0,\n    limit: int = 100,\n) -&gt; List[User]:\n    \"\"\"\n    Retrieve users. Admin only.\n\n    Args:\n        service: The user service instance.\n        current_admin: The currently authenticated admin user.\n        skip: Number of records to skip.\n        limit: Maximum number of records to return.\n\n    Returns:\n        List[User]: A list of users.\n    \"\"\"\n    return await service.get_multi(skip=skip, limit=limit)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.update_user","title":"<code>update_user(*, user_id, user_in, service, current_admin)</code>  <code>async</code>","text":"<p>Update a user. Admin only.</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the user to update.</p> </li> <li> <code>user_in</code>               (<code>UserUpdate</code>)           \u2013            <p>The user update data.</p> </li> <li> <code>service</code>               (<code>Annotated[UserService, Depends(get_user_service)]</code>)           \u2013            <p>The user service instance.</p> </li> <li> <code>current_admin</code>               (<code>Annotated[User, Depends(get_current_admin)]</code>)           \u2013            <p>The currently authenticated admin user.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>User</code> (              <code>User</code> )          \u2013            <p>The updated user object.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.patch(\"/{user_id}\", response_model=UserRead)\nasync def update_user(\n    *,\n    user_id: UUID,\n    user_in: UserUpdate,\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_admin: Annotated[User, Depends(get_current_admin)],\n) -&gt; User:\n    \"\"\"\n    Update a user. Admin only.\n\n    Args:\n        user_id: The ID of the user to update.\n        user_in: The user update data.\n        service: The user service instance.\n        current_admin: The currently authenticated admin user.\n\n    Returns:\n        User: The updated user object.\n    \"\"\"\n    return await service.update(user_id, user_in)\n</code></pre>"},{"location":"api/v1/users/#app.api.v1.endpoints.users.upload_user_avatar","title":"<code>upload_user_avatar(*, user_id, file=File(...), service, current_user)</code>  <code>async</code>","text":"<p>Upload an avatar image for a user.</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>UUID</code>)           \u2013            <p>The ID of the user.</p> </li> <li> <code>file</code>               (<code>UploadFile</code>, default:                   <code>File(...)</code> )           \u2013            <p>The avatar image file to upload.</p> </li> <li> <code>service</code>               (<code>Annotated[UserService, Depends(get_user_service)]</code>)           \u2013            <p>The user service instance.</p> </li> <li> <code>current_user</code>               (<code>Annotated[User, Depends(get_current_user)]</code>)           \u2013            <p>The currently authenticated user.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>If the user is not authorized.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>User</code> (              <code>User</code> )          \u2013            <p>The updated user object.</p> </li> </ul> Source code in <code>app/api/v1/endpoints/users.py</code> <pre><code>@router.post(\"/{user_id}/avatar\", response_model=UserRead)\nasync def upload_user_avatar(\n    *,\n    user_id: UUID,\n    file: UploadFile = File(...),\n    service: Annotated[UserService, Depends(get_user_service)],\n    current_user: Annotated[User, Depends(get_current_user)],\n) -&gt; User:\n    \"\"\"\n    Upload an avatar image for a user.\n\n    Args:\n        user_id: The ID of the user.\n        file: The avatar image file to upload.\n        service: The user service instance.\n        current_user: The currently authenticated user.\n\n    Raises:\n        HTTPException: If the user is not authorized.\n\n    Returns:\n        User: The updated user object.\n    \"\"\"\n    if current_user.id != user_id and current_user.role != UserRole.ADMIN:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    return await service.upload_avatar(user_id, file)\n</code></pre>"},{"location":"api/v1/ws/","title":"WebSockets","text":"<p>WebSocket API endpoints for the Vectra backend.</p> <p>This module provides the WebSocket endpoint for both frontend clients and the Python worker, handling real-time communication and status updates.</p>"},{"location":"api/v1/ws/#app.api.v1.ws.ClientType","title":"<code>ClientType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enumeration for different types of WebSocket clients.</p> <p>Attributes:</p> <ul> <li> <code>CLIENT</code>           \u2013            <p>Represents a frontend client (e.g., React Dashboard).</p> </li> <li> <code>WORKER</code>           \u2013            <p>Represents the backend Python worker.</p> </li> </ul> Source code in <code>app/api/v1/ws.py</code> <pre><code>class ClientType(StrEnum):\n    \"\"\"\n    Enumeration for different types of WebSocket clients.\n\n    Attributes:\n        CLIENT: Represents a frontend client (e.g., React Dashboard).\n        WORKER: Represents the backend Python worker.\n    \"\"\"\n\n    CLIENT = \"client\"\n    WORKER = \"worker\"\n</code></pre>"},{"location":"api/v1/ws/#app.api.v1.ws.websocket_endpoint","title":"<code>websocket_endpoint(websocket, manager=Depends(get_websocket), client_type=Query(ClientType.CLIENT), token=Query(default=None))</code>  <code>async</code>","text":"<p>WebSocket Endpoint handling both Frontend clients and the Python Worker.</p> <p>This endpoint manages the lifecycle of WebSocket connections, including handshake, security checks, message processing, and disconnection. Workers must provide valid authentication using a secret token.</p> <p>Protocol: - Frontend clients connect with <code>client_type=client</code>. - Workers connect with <code>client_type=worker</code> and must provide <code>x-worker-secret</code>   header or a <code>token</code> query parameter matching <code>settings.WORKER_SECRET</code>.</p> <p>Parameters:</p> <ul> <li> <code>websocket</code>               (<code>WebSocket</code>)           \u2013            <p>The WebSocket connection instance.</p> </li> <li> <code>manager</code>               (<code>Websocket</code>, default:                   <code>Depends(get_websocket)</code> )           \u2013            <p>Singleton manager for handling active connections.</p> </li> <li> <code>client_type</code>               (<code>ClientType</code>, default:                   <code>Query(CLIENT)</code> )           \u2013            <p>Type of the connecting client (client or worker). Defaults to ClientType.CLIENT.</p> </li> <li> <code>token</code>               (<code>Optional[str]</code>, default:                   <code>Query(default=None)</code> )           \u2013            <p>Optional authentication token (used if x-worker-secret header is missing).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>WebSocketDisconnect</code>             \u2013            <p>When the client disconnects normally.</p> </li> </ul> Source code in <code>app/api/v1/ws.py</code> <pre><code>@router.websocket(\"/ws\")\nasync def websocket_endpoint(\n    websocket: WebSocket,\n    manager: Websocket = Depends(get_websocket),\n    client_type: ClientType = Query(ClientType.CLIENT),\n    token: Optional[str] = Query(default=None),\n) -&gt; None:\n    \"\"\"\n    WebSocket Endpoint handling both Frontend clients and the Python Worker.\n\n    This endpoint manages the lifecycle of WebSocket connections, including\n    handshake, security checks, message processing, and disconnection.\n    Workers must provide valid authentication using a secret token.\n\n    Protocol:\n    - Frontend clients connect with `client_type=client`.\n    - Workers connect with `client_type=worker` and must provide `x-worker-secret`\n      header or a `token` query parameter matching `settings.WORKER_SECRET`.\n\n    Args:\n        websocket: The WebSocket connection instance.\n        manager: Singleton manager for handling active connections.\n        client_type: Type of the connecting client (client or worker).\n            Defaults to ClientType.CLIENT.\n        token: Optional authentication token (used if x-worker-secret header is missing).\n\n    Returns:\n        None\n\n    Raises:\n        WebSocketDisconnect: When the client disconnects normally.\n    \"\"\"\n    func_name: str = \"websocket_endpoint\"\n\n    logger.debug(f\"CONNECT | {func_name} | Incoming connection [Type: {client_type}]\")\n\n    # 1. Connection Phase &amp; Authentication\n    try:\n        if client_type == ClientType.WORKER:\n            # Extract secret from headers or query param\n            secret: Optional[str] = websocket.headers.get(\"x-worker-secret\")\n\n            if not secret and token:\n                secret = token\n\n            # Securely compare secrets to prevent timing attacks\n            expected_secret = str(settings.WORKER_SECRET)\n            if not secret or not secrets.compare_digest(secret, expected_secret):\n                logger.warning(\n                    f\"SECURITY | {func_name} | Unauthorized Worker Attempt. \"\n                    f\"Received: {secret!r} | Expected: [REDACTED]\"\n                )\n                await websocket.close(code=status.WS_1008_POLICY_VIOLATION)\n                return\n\n        # Accept connection and add to manager\n        await manager.connect(websocket)\n\n        conn_id: str = str(getattr(websocket, \"conn_id\", \"unknown\"))\n        if client_type == ClientType.WORKER:\n            logger.info(f\"START | {func_name} | Secure Worker Connected [ID: {conn_id}]\")\n            await manager.register_worker(websocket)\n        else:\n            logger.debug(f\"START | {func_name} | Client Connected [ID: {conn_id}]\")\n\n    except Exception as e:\n        logger.error(f\"FAIL | {func_name} | Connection refused or failed during setup | Error: {e}\", exc_info=True)\n        return\n\n    # 2. Communication Loop\n    try:\n        while True:\n            # Wait for text messages\n            data: str = await websocket.receive_text()\n\n            # Heartbeat check\n            if data == \"ping\":\n                await websocket.send_text(\"pong\")\n                continue\n\n            # Status request\n            if data == \"get_worker_status\":\n                await manager.emit_worker_status(manager.is_worker_online)\n                continue\n\n            # Worker Broadcast: Re-broadcast worker messages to all frontend clients\n            if client_type == ClientType.WORKER:\n                try:\n                    payload: Any = json.loads(data)\n                    if isinstance(payload, dict):\n                        await manager.broadcast(payload)\n                    else:\n                        logger.warning(f\"Context | {func_name} | Msg: Worker sent non-dictionary JSON: {type(payload)}\")\n                except json.JSONDecodeError as e:\n                    logger.warning(f\"Context | {func_name} | Msg: Invalid JSON from worker | Error: {e!r}\")\n                except Exception as e:\n                    logger.error(\n                        f\"FAIL | {func_name} | Worker broadcast error | Error: {e}\",\n                        exc_info=True,\n                    )\n\n    except WebSocketDisconnect as e:\n        logger.info(f\"FINISH | {func_name} | {client_type.value.capitalize()} Disconnected [Code: {e.code}]\")\n    except RuntimeError as e:\n        if 'Need to call \"accept\" first' in str(e):\n            logger.info(f\"FINISH | {func_name} | {client_type.value.capitalize()} Disconnected (Handshake incomplete)\")\n        else:\n            logger.error(f\"FAIL | {func_name} | Runtime error in WS loop | Error: {e!r}\", exc_info=True)\n    except Exception as e:\n        logger.error(f\"FAIL | {func_name} | Unexpected error in WS loop | Error: {e!r}\", exc_info=True)\n\n    finally:\n        # 3. Cleanup Phase\n        try:\n            await manager.disconnect(websocket)\n        except Exception as e:\n            logger.debug(f\"Cleanup | {func_name} | Disconnect failed (likely already closed) | Error: {e}\")\n</code></pre>"}]}